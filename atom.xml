<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[xixitalk's snippet]]></title>
  <link href="http://xixitalk.github.io/atom.xml" rel="self"/>
  <link href="http://xixitalk.github.io/"/>
  <updated>2016-11-12T07:53:39+00:00</updated>
  <id>http://xixitalk.github.io/</id>
  <author>
    <name><![CDATA[xixitalk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[华硕路由器外接硬盘格式化成什么格式最好]]></title>
    <link href="http://xixitalk.github.io/blog/2016/11/12/How-to-Format-Usb-Drive-for-asus-router/"/>
    <updated>2016-11-12T15:33:41+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/11/12/How-to-Format-Usb-Drive-for-asus-router</id>
    <content type="html"><![CDATA[<p>关键词：华硕 AC66U AC68U 外接硬盘 文件系统 EXT4 EXT3 NTFS FAT32</p>

<p>我有一台华硕AC66U，外接了一块2.5吋移动硬盘。不知道格式化成什么格式最好？硬盘本来是EXT4格式的，插上发现没有自动挂载，搜索发现，AC66U建议用<strong>EXT3</strong>格式，而AC68U建议用<strong>EXT4</strong>格式。果然格式成ext3后，插上AC66U后<strong>自动挂载</strong>了。其他华硕机器未验证。</p>

<!--more-->

<blockquote>
  <p>For usb hdd Mipsel devices is EXT3 (RT-N16, RT-N66U, RT-AC66U and all other versions: /R /W)</p>
</blockquote>

<p>RT-N16, RT-N66U, RT-AC66U是<a href="https://en.wikipedia.org/wiki/MIPS_instruction_set">MIPS</a>架构的CPU，建议最好格式化成EXT3.</p>

<blockquote>
  <p>For usb hdd ARM devices is EXT4 (RT-AC56U, RT-AC68U, RT-AC87U, RT-AC88U, RT-AC3200, RT-AC5300 and all other versions: /P /R /W)</p>
</blockquote>

<p>RT-AC56U, RT-AC68U, RT-AC87U, RT-AC88U, RT-AC3200, RT-AC5300是<a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a>架构的CPU，建议最好格式化成EXT4.</p>

<p>华硕路由器系统是Linux，对windows的NTFS和FAT32支持并不好，所以建议外接硬盘使用EXT4或者EXT3，如果不支持也许应该升级个路由器了。</p>

<h2 id="section">参考文章</h2>

<p><a href="https://www.hqt.ro/how-to-format-usb-drive/">How to Format Usb Drive</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pkcs11-helper编译]]></title>
    <link href="http://xixitalk.github.io/blog/2016/11/01/pkcs11-helper-build/"/>
    <updated>2016-11-01T18:37:08+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/11/01/pkcs11-helper-build</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/OpenSC/pkcs11-helper/releases">pkcs11-helper</a>也真是的，软件包里<code>INSTALL</code>里说用<code>./configure</code>生成<code>Makefile</code>，但是软件包还没有<code>configure</code>文件，需要<code>autoreconf</code>生成<code>configure</code>文件。妈蛋，<code>INSTALL</code>多写一句<code>autoreconf -ivf</code>会死吗？</p>

<!--more-->

<h1 id="section">准备</h1>

<p>确保系统安装了<code>autoconf</code> <code>automake</code> <code>libtool</code></p>

<h1 id="section-1">下载源代码解压</h1>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$wget https://github.com/OpenSC/pkcs11-helper/archive/pkcs11-helper-1.10.tar.gz
</span><span class="line">$tar -zxvf pkcs11-helper-1.10.tar.gz
</span><span class="line">$cd pkcs11-helper-pkcs11-helper-1.10
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h1 id="makefile">生成Makefile</h1>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$autoreconf -ivf
</span><span class="line">$./configure
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h1 id="section-2">编译安装</h1>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$make
</span><span class="line">$make install
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h1 id="section-3">参考</h1>

<p><a href="https://github.com/OpenSC/pkcs11-helper/issues/2">https://github.com/OpenSC/pkcs11-helper/issues/2</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[西部数据硬盘Load_Cycle_Count增长过快的问题]]></title>
    <link href="http://xixitalk.github.io/blog/2016/10/31/Western-Digital-problems/"/>
    <updated>2016-10-31T08:39:21+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/10/31/Western-Digital-problems</id>
    <content type="html"><![CDATA[<p>关键词：硬盘 西部数据 希捷 东芝 </p>

<p>我有一块西部数据的3.5寸硬盘，同时有一块笔记本淘汰下来的东芝的2.5寸硬盘，关键数据用这两个硬盘进行备份。最近东芝的硬盘偶尔读取失败，所以寻思再买一块硬盘替代东芝的这块硬盘。于是在网上搜索到底是买西部数据还是希捷，还是东芝的硬盘。搜索发现了西部数据硬盘曾经有“Load_Cycle_Count”的问题:<a href="https://blog.vandenbrand.org/2012/04/05/western-digital-green-caviar-wd10eads-and-hdparm-problems/">Western Digital Green Caviar WD10EADS and hdparm problems</a>
，一看我用着的这块西部数据硬盘恰恰中招了，并且寿命快终结了。</p>

<!--more-->

<p>西部数据官方网站对这个问题的解释：<a href="http://support.wdc.com/knowledgebase/answer.aspx?ID=5357">The S.M.A.R.T Attribute 193 Load/Unload counter keeps increasing on a SATA 2 hard drive</a></p>

<p>受影响的型号：</p>

<ol>
  <li>WD20EADS</li>
  <li>WD20EARS</li>
  <li>WD15EADS</li>
  <li>WD15EARS</li>
  <li>WD10EADS</li>
  <li>WD10EARS</li>
  <li>WD8000AARS</li>
  <li>WD7500AADS</li>
  <li>WD7500AARS</li>
  <li>WD6400AADS</li>
  <li>WD6400AARS</li>
  <li>WD5000AADS</li>
  <li>WD5000AARS</li>
</ol>

<p>我的硬盘型号是<code>Device Model:     WDC WD20EARS-00MVWB1</code>，2T的3.5寸硬盘。我买的是西部数据 Elements Desktop 3.5寸外置硬盘2T （WDBAAU0020HBK），专门为树莓派买的，所以直接买的是西部数据外置硬盘，USB接口输出，里面是一块绿盘<code>WD20EARS-00MVWB1</code>，购买时间是2011.8.18号，到目前已经5年了。</p>

<p>今天（2016.10.31）SMART信息如下</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class=""><span class="line">SMART Attributes Data Structure revision number: 16
</span><span class="line">Vendor Specific SMART Attributes with Thresholds:
</span><span class="line">ID# ATTRIBUTE_NAME          FLAG     VALUE WORST THRESH TYPE      UPDATED  WHEN_FAILED RAW_VALUE
</span><span class="line">  1 Raw_Read_Error_Rate     0x002f   200   200   051    Pre-fail  Always       -       0
</span><span class="line">  3 Spin_Up_Time            0x0027   166   160   021    Pre-fail  Always       -       6691
</span><span class="line">  4 Start_Stop_Count        0x0032   091   091   000    Old_age   Always       -       9326
</span><span class="line">  5 Reallocated_Sector_Ct   0x0033   200   200   140    Pre-fail  Always       -       0
</span><span class="line">  7 Seek_Error_Rate         0x002e   200   200   000    Old_age   Always       -       0
</span><span class="line">  9 Power_On_Hours          0x0032   059   059   000    Old_age   Always       -       30290
</span><span class="line"> 10 Spin_Retry_Count        0x0032   100   100   000    Old_age   Always       -       0
</span><span class="line"> 11 Calibration_Retry_Count 0x0032   100   100   000    Old_age   Always       -       0
</span><span class="line"> 12 Power_Cycle_Count       0x0032   100   100   000    Old_age   Always       -       789
</span><span class="line">192 Power-Off_Retract_Count 0x0032   200   200   000    Old_age   Always       -       12
</span><span class="line">193 Load_Cycle_Count        0x0032   001   001   000    Old_age   Always       -       904905
</span><span class="line">194 Temperature_Celsius     0x0022   125   082   000    Old_age   Always       -       25
</span><span class="line">196 Reallocated_Event_Count 0x0032   200   200   000    Old_age   Always       -       0
</span><span class="line">197 Current_Pending_Sector  0x0032   200   200   000    Old_age   Always       -       0
</span><span class="line">198 Offline_Uncorrectable   0x0030   200   200   000    Old_age   Offline      -       0
</span><span class="line">199 UDMA_CRC_Error_Count    0x0032   200   200   000    Old_age   Always       -       0
</span><span class="line">200 Multi_Zone_Error_Rate   0x0008   200   200   000    Old_age   Offline      -       0
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>通电时间（Power_On_Hours）<strong>30290</strong>小时，折合3年多，对于5年多24/7接在树莓派上，也算正常。关键是Load_Cycle_Count，已经<strong>904905</strong>，90多万了。有地方说Load_Cycle_Count寿命3.5寸是30万，2.5寸是60万，我这个已经是90多万了。</p>

<p>西部数据Load_Cycle_Count增长多快的问题解决办法就是的就是官方提供的<code>wdidle3.exe</code>工具，增大休眠时间或者关闭绿盘的定时休眠功能。windows平台自行搜索使用教程。</p>

<p>西部数据官方没有提供linux下的工具，只提供windows下的工具，并且<code>wdidle3.exe</code>命令不能指定硬盘，一运行全部硬盘全部影响，建议不相关的硬盘拔掉（这是啥傻逼命令）。</p>

<p>有一个非官方的<a href="http://idle3-tools.sourceforge.net/">linux wdidle3工具</a>，开源的，可以linux平台编译，可以指定硬盘。但是发现运行的时候提示<code>HDIO_DRIVE_CMD(identify) failed: Invalid argument</code>设置失败，这个应该是<strong>西部数据SATA转USB接口的问题</strong>，如果是直接SATA接口应该没有问题，我懒得折腾了。</p>

<p>我现在成<strong>西部数据黑了</strong>，原因有三：一个是因为<code>Load_Cycle_Count</code>的问题，这么严重的问题难道都不召回吗？第二我买的Elements Desktop，官方的SATA转USB接口，使用linux最常用的硬盘工具<code>hdparm</code>竟然提示错误，不可理解。上面<code>wdidle3</code>报的一样的错误。第三真的对红紫蓝绿盘挑选厌倦了。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$sudo hdparm -i /dev/sdb
</span><span class="line">
</span><span class="line">/dev/sdb:
</span><span class="line"> HDIO_GET_IDENTITY failed: Invalid argument
</span><span class="line">$sudo hdparm -C /dev/sdb
</span><span class="line">
</span><span class="line">/dev/sdb:
</span><span class="line"> drive state is:  unknown
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我现在买了一块<strong>希捷</strong>的<code>ST4000DM000</code>，4T容量，依据<a href="https://www.backblaze.com/blog/hard-drive-reliability-stats-q1-2016/">backblaze的数据</a>，希捷的<code>ST4000DM000</code>样本足够大，出错率低。加上<strong>绿联</strong>的SATA转USB线，外接12V2A供电，目前接树莓派上使用正常，<code>hdparm</code>设置也正常，推荐使用。就不知道希捷这块<code>ST4000DM000中国专供版</code>是否和国外的品质一致了。</p>

<p>同时在这里吐槽一下SSK的2.5寸硬盘盒，竟然<code>smartctl</code>读取东芝硬盘SMART信息都读不到。所以希捷3.5寸硬盘SATA转USB我没有再考虑SSK了，买了<strong>绿联</strong>的转接线。</p>

<p><strong>2T西部数据硬盘的数据已经备份，静待他的报废</strong>，有地方说Load_Cycle_Count超过1百万会出问题，拭目以待。</p>

<p><strong>后续1</strong>：我启动<code>hd-idle</code>服务后，西部数据这块硬盘<code>Load_Cycle_Count</code>一天竟然只增加了3，通电时间增加了2小时，之前<code>Load_Cycle_Count</code>每天平均应该是495（904905/5/365），这可能和我把平常读写硬盘的程序（btsync server）停掉了有关系，硬盘休眠时间增加了，但愿它多撑一段时间吧。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编译stunnel]]></title>
    <link href="http://xixitalk.github.io/blog/2016/10/19/compile-stunnel-from-source/"/>
    <updated>2016-10-19T09:21:51+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/10/19/compile-stunnel-from-source</id>
    <content type="html"><![CDATA[<p>现在最新的stunnel是v5.36，而很多平台都还是<code>stunnel4</code></p>

<!--more-->

<p><a href="https://www.stunnel.org/downloads/stunnel-5.36.tar.gz">下载</a>stunnel-5.36.tar.gz，解压。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">wget https://www.stunnel.org/downloads/stunnel-5.36.tar.gz
</span><span class="line">tar -zxvf stunnel-5.36.tar.gz
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>用<code>./configure --help</code>查看编译配置选项。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">cd stunnel-5.36
</span><span class="line">./configure --help
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>配置选项中<code>--with-threads</code>可以配置成<code>ucontext</code>、<code>pthread</code>或者<code>fork</code>，默认是<code>pthread</code>。如果是<code>pthread</code>模式，创建一个线程处理每个连接；如果是<code>fork</code>模式，创建一个进程处理每个连接。用<code>ps aux | grep stunnel</code>查看，如果很多个<code>stunnel</code>进程，则是<code>fork</code>模式；如果只有一个<code>stunnel</code>进程，那就是<code>ucontext</code>或者<code>pthread</code>模式。<code>ucontext</code>实现了用户空间一个进程中上下文切换，用这种机制可以实现协程（Coroutine），从资源利用上来说<code>ucontext</code>比<code>pthread</code>和<code>fork</code>更好一点。<code>fork</code>方式稳定性和安全性应该最好，一是代码最简单，二是进程独立空间。<code>pthread</code>是默认配置，稳定性也有保障。</p>

<p>用<code>configure</code>生成<code>Makefile</code>，下面配置选项含义：禁用<code>ipv6</code>，禁用<a href="https://en.wikipedia.org/wiki/Federal_Information_Processing_Standards" title="fips">fips</a>，禁用TCP Wrappers，每个网络连接创建一个线程处理。选项根据自己需要增删。</p>

<p>备注：TCP Wrappers作用是用<code>/etc/hosts.allow</code> 和 <code>/etc/hosts.deny</code>进行IP地址过滤，属于安全增强。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">./configure --disable-ipv6 --disable-fips --disable-libwrap --with-threads=pthread
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>生成<code>Makefile</code>之后，<code>make</code>进行编译。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">make
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>make</code>编译完成编译好的stunnel位于<code>src/stunnel</code>，根据发行版本配置启动。我偷懒，直接覆盖了原来安装的<code>/usr/bin/stunnel4</code>命令，其他的脚本还用<code>stunnel4</code>的，目前没有发现问题。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo service  stunnel4  stop
</span><span class="line">sudo cp /usr/bin/stunnel4 /usr/bin/stunnel4.backup
</span><span class="line">sudo cp src/stunnel /usr/bin/stunnel4
</span><span class="line">sudo service  stunnel4  start
</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[stunnel verify选项配置]]></title>
    <link href="http://xixitalk.github.io/blog/2016/10/18/stunnel-verify-config/"/>
    <updated>2016-10-18T09:12:59+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/10/18/stunnel-verify-config</id>
    <content type="html"><![CDATA[<p>verify配置认证方式，取值0 1 2 3 4。</p>

<p>0 - request and ignore peer cert<br />
1 - only validate peer cert if present<br />
2 - always require a valid peer cert<br />
3 - verify peer with locally installed cert<br />
4 - ignore CA chain and only verify peer cert  </p>

<!--more-->

<h2 id="stunnel5-verify">stunnel5 verify配置</h2>

<p>代码版本<code>stunnel 5.36</code>  文件<code>option.c</code>  函数<code>parse_service_option()</code></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class=""><span class="line">case CMD_EXEC:
</span><span class="line">    if(strcasecmp(opt, "verify"))
</span><span class="line">        break;
</span><span class="line">    {
</span><span class="line">        char *tmp_str;
</span><span class="line">        int tmp_int=(int)strtol(arg, &amp;tmp_str, 10);
</span><span class="line">        if(tmp_str==arg || *tmp_str || tmp_int&lt;0 || tmp_int&gt;4)
</span><span class="line">            return "Bad verify level";
</span><span class="line">        section-&gt;option.request_cert=1;
</span><span class="line">        section-&gt;option.require_cert=(tmp_int&gt;=2);
</span><span class="line">        section-&gt;option.verify_chain=(tmp_int&gt;=1 &amp;&amp; tmp_int&lt;=3);
</span><span class="line">        section-&gt;option.verify_peer=(tmp_int&gt;=3);
</span><span class="line">    }
</span><span class="line">    return NULL; /* OK */
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>verify</code>选项合法值为：0  1 2 3 4</p>

<table>
  <thead>
    <tr>
      <th>取值</th>
      <th>request_cert</th>
      <th>require_cert</th>
      <th>verify_chain</th>
      <th>verify_peer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>√</td>
      <td>×</td>
      <td>×</td>
      <td>×</td>
    </tr>
    <tr>
      <td>1</td>
      <td>√</td>
      <td>×</td>
      <td>√</td>
      <td>×</td>
    </tr>
    <tr>
      <td>2</td>
      <td>√</td>
      <td>√</td>
      <td>√</td>
      <td>×</td>
    </tr>
    <tr>
      <td>3</td>
      <td>√</td>
      <td>√</td>
      <td>√</td>
      <td>√</td>
    </tr>
    <tr>
      <td>4</td>
      <td>√</td>
      <td>√</td>
      <td>×</td>
      <td>√</td>
    </tr>
  </tbody>
</table>

<p>conf配置文件里，<code>requireCert</code>可以修改require_cert，<code>verifyChain</code>可以修改<code>verify_chain</code>，<code>verifyPeer</code>可以修改<code>verify_peer</code>。</p>

<p>根据上表可得出，stunnel5里<code>verify = 3</code>最全面。</p>

<p>我自己服务器端是<code>verify = 3</code>，客户端用的是<code>verify = 4</code>。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">verify = 4
</span><span class="line">verifyChain = no
</span><span class="line">verifyPeer = yes
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果是stunnel4，配置<code>verify = 3</code>即可，点对点连接推荐3。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[stunnel双向证书认证]]></title>
    <link href="http://xixitalk.github.io/blog/2016/10/13/Stunnel-With-Bilateral-Authentication/"/>
    <updated>2016-10-13T20:09:49+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/10/13/Stunnel-With-Bilateral-Authentication</id>
    <content type="html"><![CDATA[<p>stunnel 双向证书认证：<strong>防止没授权的客户端连接stunnel服务器，防止客户端连接假的服务器</strong>。</p>

<p>stunnel官方的<a href="https://www.stunnel.org/auth.html">说明</a>是：（客户端）检查服务器端证书是为了防止<strong>中间人攻击</strong>；（服务器端）检查客户端证书是为了严格控制客户端的访问。</p>

<ol>
  <li>Server authentication prevents <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">Man-In-The-Middle</a> (MITM) attacks on the encryption protocol.</li>
  <li>Client authentication allows for restricting access for individual clients (access control).</li>
</ol>

<!--more-->

<h2 id="stunnel">stunnel安全说明</h2>

<p>stunnel有四种证书检查配置，用<code>verify</code>选项控制。</p>

<ol>
  <li><strong>Do not Verify Certificates</strong>  不检查证书，<strong>默认值</strong><br />
If no verify argument is given, then stunnel will ignore any certificates offered and will allow all connections.</li>
  <li><strong>verify = 1</strong>  如果证书存在则检查证书<br />
Verify the certificate, if present.  </li>
  <li><strong>verify = 2</strong>  每个SSL连接要求检查证书<br />
Require and verify certificates<br />
Stunnel will require and verify certificates for every SSL connection. If no certificate or an invalid certificate is presented, then it will drop the connection.</li>
  <li><strong>verify = 3</strong>  依据本地安装的证书检查证书<br />
Require and verify certificates against locally installed certificates.</li>
  <li><strong>verify = 4</strong>  忽略CA chain，只验证peer certificate<br />
ignore CA chain and only verify peer certificate</li>
</ol>

<p>当<code>verify</code>配置2 3 4的时候，都会开启双向证书认证，自行选择。这里选择<code>verify = 3</code>。</p>

<p>stunnel服务端的<strong>防盗</strong>连安全机制是：在服务器<code>CAfile</code>里配置客户端的证书，并设置<code>verify = 3</code>，服务器端检查客户端证书，证书不在<code>CAfile</code>列表的客户端则会被断开连接。</p>

<p>同样，为了避免客户端连接到<strong>假的服务端</strong>，则需要配置<code>verify = 3</code>，并把服务端的<strong>公钥证书</strong>放在客户端侧的<code>CAfile</code>里。</p>

<h2 id="section">第一步 生成证书</h2>

<p>生成两个证书，一个服务端的<code>stunnel_s.pem</code>，一个客户端的<code>stunnel_c.pem</code>，有效期设置长一点，10000天，时间可以自行调整。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$openssl req -new -x509 -days 10000 -nodes -out stunnel_c.pem -keyout stunnel_c.pem
</span><span class="line">$openssl req -new -x509 -days 10000 -nodes -out stunnel_s.pem -keyout stunnel_s.pem
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="stunnelconf">第二步 服务器端stunnel.conf</h2>

<p>将证书拷贝到/etc/stunnel目录，设置权限400（文件拥有者只读，其他人不可查看）.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$sudo cp stunnel_s.pem /etc/stunnel/
</span><span class="line">$sudo cp stunnel_c.pem /etc/stunnel/
</span><span class="line">$sudo chmod 400 /etc/stunnel/*.pem
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>创建<code>stunnel.conf</code>文件，内容如下，拷贝到<code>/etc/stunnel/</code>目录。对外端口是8445，加密的是<a href="https://github.com/cyfdecyf/cow">cow HTTP proxy</a>的7777端口连接,根据情况自行修改。如果要调试打开<code>output</code>选项。cow是个HTTP代理，智能分流值得推荐。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class=""><span class="line">;fips=no
</span><span class="line">client = no
</span><span class="line">sslVersion=all
</span><span class="line">
</span><span class="line">chroot = /var/lib/stunnel4/
</span><span class="line">setuid = root
</span><span class="line">setgid = root
</span><span class="line">
</span><span class="line">pid = /stunnel4.open.pid
</span><span class="line">;output = /stunnel.open.log
</span><span class="line">cert = /etc/stunnel/stunnel_s.pem
</span><span class="line">key = /etc/stunnel/stunnel_s.pem
</span><span class="line">
</span><span class="line">[open]
</span><span class="line">accept = 8445
</span><span class="line">connect = 7777
</span><span class="line">
</span><span class="line">verify = 3
</span><span class="line">CAfile = /etc/stunnel/stunnel_c.pem
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>重启stunnel服务器</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$sudo service  stunnel4  restart
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="stunnelconf-1">第三步 客户端stunnel.conf</h2>

<p>我的客户端运行在windows系统，所以下面的配置是windows上stunnel验证的。其他系统配置类似，自行配置验证。</p>

<p>将<code>stunnel_c.pem</code>和<code>stunnel_s.pem</code>（存放在客户端的stunnel_s.pem最好删除证书里BEGIN PRIVATE KEY私钥部分，只保留BEGIN CERTIFICATE公钥部分）拷贝到<code>stunnel</code>安装目录，修改<code>stunnel.conf</code>文件，配置如下。<code>stunnel_ip</code>是服务器端stunnel的IP，端口是8084，浏览器配置127.0.0.1:8084 HTTP代理。如果要换其他端口自行修改。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class=""><span class="line">fips=no
</span><span class="line">client = yes
</span><span class="line">sslVersion = all
</span><span class="line">socket = l:TCP_NODELAY=1
</span><span class="line">socket = r:TCP_NODELAY=1
</span><span class="line">socket = l:SO_LINGER=1:1
</span><span class="line">socket = r:SO_LINGER=1:1
</span><span class="line">
</span><span class="line">[fastssl]
</span><span class="line">accept = 127.0.0.1:8084
</span><span class="line">connect = stunnel_ip:8445
</span><span class="line">
</span><span class="line">verify = 3
</span><span class="line">CAfile = stunnel_s.pem
</span><span class="line">
</span><span class="line">cert = stunnel_c.pem
</span><span class="line">key = stunnel_c.pem
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果客户端连接<code>stunnel</code>服务器端需要HTTP代理（公司网络），<code>fastssl</code>部分这样配置</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">[fastssl]
</span><span class="line">accept = 127.0.0.1:8084
</span><span class="line">connect = proxy.company.com:80
</span><span class="line">protocol = connect
</span><span class="line">protocolHost = stunnel_ip:8445
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="pem">pem证书安全存放说明</h2>

<p>pem证书是文本文件，里面<code>BEGIN PRIVATE KEY</code>和<code>END PRIVATE KEY</code>是私钥部分，<code>BEGIN CERTIFICATE</code>和<code>END CERTIFICATE</code>是公钥部分。<code>cert</code>和<code>key</code>配置完整的pem，而<code>CAfile</code>里只包含对方的公钥部分即可，即服务端<code>CAfile</code>是客户端的公钥，客户端<code>CAfile</code>是服务端的公钥。遵循这样原则，客户端的私钥只放客户端，服务端的私钥只放服务端，而公钥是可以多处存放的。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class=""><span class="line">-----BEGIN PRIVATE KEY-----
</span><span class="line">MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQCo9WC13gg9WCRX
</span><span class="line">...
</span><span class="line">kPpWg2PAANRi5Bmr9ScvBISSYQ==
</span><span class="line">-----END PRIVATE KEY-----
</span><span class="line">-----BEGIN CERTIFICATE-----
</span><span class="line">MIID6TCCAtGgAwIBAgIJANBMqvP0YuV4MA0GCSqGSIb3DQEBBQUAMIGKMQswCQYD
</span><span class="line">...
</span><span class="line">o5tKoL9GcMhyjDoD9GCMfP6fY5DwPqhhqFTsPd47DzEdQ8amxPMn5kR/w/xk
</span><span class="line">-----END CERTIFICATE-----
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>多个公钥证书保存在一个<code>CAfile</code>里，这样排列存放。<a href="https://www.stunnel.org/howto.html">官方说明Where do I put all these certificates?</a>。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">-----BEGIN CERTIFICATE-----
</span><span class="line">certificate #1 data here
</span><span class="line">-----END CERTIFICATE-----
</span><span class="line">-----BEGIN CERTIFICATE-----
</span><span class="line">certificate #2 data here
</span><span class="line">-----END CERTIFICATE-----
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-1">参考博客</h2>

<ol>
  <li><a href="http://www.hawu.me/operation/886">squid + stunnel » 跨越长城，科学上网！</a></li>
  <li><a href="http://briteming.blogspot.com/2013/03/stunnel.html">Using stunnel With Bilateral Authentication</a></li>
  <li><a href="https://sunmaiblog.wordpress.com/2010/09/21/stunnel%E7%9A%84%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/">Stunnel的设置和使用</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress里用表格]]></title>
    <link href="http://xixitalk.github.io/blog/2016/10/12/table-in-octopress/"/>
    <updated>2016-10-12T10:53:20+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/10/12/table-in-octopress</id>
    <content type="html"><![CDATA[<p>octopress里怎么样用表格？octopress默认的表格border是0，看起来不整齐。这样修改可以显示border。</p>

<!--more-->

<h2 id="octopresscss">步骤一 覆盖octopress默认的CSS</h2>

<p>表格要显示border，需要这样修改。</p>

<p>参考他人博文：<a href="http://programus.github.io/blog/2012/03/07/add-table-data-css-for-octopress/">为Octopress追加数据表格的CSS</a></p>

<h2 id="markdown">步骤二 博文markdown格式</h2>

<p>博文报头增加<code>styles</code>选项：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">layout: post
</span><span class="line">title: "octopress里用表格"
</span><span class="line">date: 2016-10-12 10:53:20
</span><span class="line">comments: true
</span><span class="line">categories: octopress
</span><span class="line">styles: data-table
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>表格markdown这样写，我的octopress用的是<code>Kramdown</code>，其他markdown语法类似。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">|类型值|解释|
</span><span class="line">|----|----|
</span><span class="line">|0x0800 | 网际协议（IP）|
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>显示效果如下：</p>

<table>
  <thead>
    <tr>
      <th>类型值</th>
      <th>解释</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x0800</td>
      <td>网际协议（IP）</td>
    </tr>
  </tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DNS协议学习笔记之DNS查询]]></title>
    <link href="http://xixitalk.github.io/blog/2016/10/10/dns-protocol/"/>
    <updated>2016-10-10T19:00:54+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/10/10/dns-protocol</id>
    <content type="html"><![CDATA[<p>DNS学习概要：  </p>

<ol>
  <li>DNS几个概念：A记录、AAAA记录、MX记录、CNAME记录、TEXT记录、URL转发、NS记录</li>
  <li>DNS查询报文</li>
  <li>DNS响应报文</li>
  <li>Google DNS over HTTPS</li>
</ol>

<!--more-->

<h2 id="dns">1.  DNS几个概念</h2>

<p>DNS几个概念，参看这两篇文章：</p>

<p><a href="https://www.ezloo.com/2011/04/a_mx_cname_txt_aaaa_ns.html">常用域名记录解释：A记录、MX记录、CNAME记录、TXT记录、AAAA记录、NS记录</a></p>

<p><a href="http://ju.outofmemory.cn/entry/187521">域名DNS解析相关概念 — A记录，MX记录，CNAME记录，url转发，ns记录</a></p>

<h2 id="dns-1">2. DNS查询报文</h2>

<h3 id="section">2.1 整体结构</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">+---------------------+
</span><span class="line">|        Header       |
</span><span class="line">+---------------------+
</span><span class="line">|       Question      | the question for the name server
</span><span class="line">+---------------------+
</span><span class="line">|        Answer       | RRs answering the question
</span><span class="line">+---------------------+
</span><span class="line">|      Authority      | RRs pointing toward an authority
</span><span class="line">+---------------------+
</span><span class="line">|      Additional     | RRs holding additional information
</span><span class="line">+---------------------+
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://s6.51cto.com/wyfs02/M02/4D/A8/wKiom1RW2KaCvqHrAABEwMOH0AE633.jpg" alt="DNSrequest" /></p>

<h3 id="section-1">2.2 报文头</h3>

<p><img src="http://xixitalkgithubio.qiniudn.com/dnsheader.jpg" alt="DNSrequest2" /></p>

<table border="1">
  <tbody>
    <tr>
      <td>16位标识</td>
      <td>16位标志</td>
    </tr>
    <tr>
      <td>16位问题数</td>
      <td>16资源记录数</td>
    </tr>
    <tr>
      <td>16位授权资源记录数</td>
      <td>16位额外资源记录数</td>
    </tr>
  </tbody>
</table>

<p>整个DNS包头12个字节。  </p>

<p><strong>16位标志详解</strong></p>

<table border="1">
  <tbody>
    <tr>
      <td>1位QR</td>
      <td>4位Opcode</td>
      <td>1位AA</td>
      <td>1位TC</td>
      <td>1位RD</td>
      <td>1位RA</td>
      <td>3位清0</td>
      <td>4位RCode</td>
    </tr>
  </tbody>
</table>

<p>QR：0表示查询报文，1表示响应报文<br />
Opcode：通常值为0(标准查询)，其他值为1(反向查询)和2(服务器状态请求)。<br />
AA：表示授权回答(authoritative answer).<br />
TC：表示可截断的(truncated)<br />
RD：表示期望递归<br />
RA：表示可用递归，随后3bit必须为0<br />
RCode：返回码，通常为0(没有差错)和3(出错，该域名不存在)  </p>

<h3 id="question">2.3 查询问题(Question)结构</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class=""><span class="line">
</span><span class="line">                                    1  1  1  1  1  1
</span><span class="line">      0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
</span><span class="line">    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
</span><span class="line">    |                                               |
</span><span class="line">    /                     QNAME                     /
</span><span class="line">    /                                               /
</span><span class="line">    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
</span><span class="line">    |                     QTYPE                     |
</span><span class="line">    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
</span><span class="line">    |                     QCLASS                    |
</span><span class="line">    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>QNAME结构：<strong>域名字符串按照<code>.</code>分割，按照字符长度+字符依次排列，00结尾</strong>。</p>

<p>比如www.google.com.hk，在抓包里QNAME的视图如下：</p>

<p><strong>03</strong> 77 77 77 <strong>06</strong> 67 6f 6f 67 6c 65 <strong>03</strong> 63 6f 6d <strong>02</strong> 68 6b 00</p>

<p>解读：03个字符（www），06个字符（google），03个字符（com），02个字符（hk），结尾是00</p>

<p>QType：长度16位，表示查询类型<br />
QClass:长度为16位，表示分类</p>

<h2 id="dns-2">2.4  一个典型的DNS查询包</h2>

<p>下面是<code>wireshark</code>抓取的一个DNS查询包：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">(前面是以太网包头+IP包头+UDP包头)6d 54 01 00 00 01
</span><span class="line">00 00 00 00 00 00 03 77    77 77 06 67 6f 6f 67 6c 
</span><span class="line">65 03 63 6f 6d 02 68 6b    00 00 01 00 01
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>6d 54</code>是标识，每次查询变化，DNS回应本次查询会用相同的标识<br />
<code>01 00</code>是标志，表示RD期望递归为1<br />
<code>00 01</code>是问题数，一个问题查询；其他三个查询记录数都是0<br />
接下来是QName，结构如上文说明<br />
倒数第二个<code>00 01</code>是QType，值是1<br />
最后一个<code>00 01</code>是QClass，值是是1  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class=""><span class="line">enum QueryType //查询的资源记录类型。 
</span><span class="line">{ 
</span><span class="line">A=0x01, //指定计算机 IP 地址。 
</span><span class="line">NS=0x02, //指定用于命名区域的 DNS 名称服务器。 
</span><span class="line">MD=0x03, //指定邮件接收站（此类型已经过时了，使用MX代替） 
</span><span class="line">MF=0x04, //指定邮件中转站（此类型已经过时了，使用MX代替） 
</span><span class="line">CNAME=0x05, //指定用于别名的规范名称。 
</span><span class="line">SOA=0x06, //指定用于 DNS 区域的“起始授权机构”。 
</span><span class="line">MB=0x07, //指定邮箱域名。 
</span><span class="line">MG=0x08, //指定邮件组成员。 
</span><span class="line">MR=0x09, //指定邮件重命名域名。 
</span><span class="line">NULL=0x0A, //指定空的资源记录 
</span><span class="line">WKS=0x0B, //描述已知服务。 
</span><span class="line">PTR=0x0C, //如果查询是 IP 地址，则指定计算机名；否则指定指向其它信息的指针。 
</span><span class="line">HINFO=0x0D, //指定计算机 CPU 以及操作系统类型。 
</span><span class="line">MINFO=0x0E, //指定邮箱或邮件列表信息。 
</span><span class="line">MX=0x0F, //指定邮件交换器。 
</span><span class="line">TXT=0x10, //指定文本信息。 
</span><span class="line">UINFO=0x64, //指定用户信息。 
</span><span class="line">UID=0x65, //指定用户标识符。 
</span><span class="line">GID=0x66, //指定组名的组标识符。 
</span><span class="line">ANY=0xFF //指定所有数据类型。 
</span><span class="line">};
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">enum QueryClass //指定信息的协议组。 
</span><span class="line">{ 
</span><span class="line">IN=0x01, //指定 Internet 类别。 
</span><span class="line">CSNET=0x02, //指定 CSNET 类别。（已过时） 
</span><span class="line">CHAOS=0x03, //指定 Chaos 类别。 
</span><span class="line">HESIOD=0x04,//指定 MIT Athena Hesiod 类别。 
</span><span class="line">ANY=0xFF //指定任何以前列出的通配符。 
</span><span class="line">};
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-2">学习资料</h3>

<ol>
  <li>
    <p><a href="https://www.ietf.org/rfc/rfc1035.txt">rfc1035</a></p>
  </li>
  <li>
    <p><a href="http://www.zytrax.com/books/dns/ch15/">Chapter 15 DNS Messages</a></p>
  </li>
  <li>
    <p><a href="http://www.iprotocolsec.com/2012/01/13/%E4%BD%BF%E7%94%A8wireshark%E5%AD%A6%E4%B9%A0dns%E5%8D%8F%E8%AE%AE%E5%8F%8Adns%E6%AC%BA%E9%AA%97%E5%8E%9F%E7%90%86/">使用Wireshark学习DNS协议及DNS欺骗原理</a></p>
  </li>
  <li>
    <p><a href="http://www.cnblogs.com/topdog/archive/2011/11/15/2250185.html">DIY一个DNS查询器：了解DNS协议</a></p>
  </li>
  <li>
    <p><a href="https://www.ezloo.com/2011/04/a_mx_cname_txt_aaaa_ns.html">常用域名记录解释：A记录、MX记录、CNAME记录、TXT记录、AAAA记录、NS记录</a></p>
  </li>
  <li>
    <p><a href="http://ju.outofmemory.cn/entry/187521">域名DNS解析相关概念 — A记录，MX记录，CNAME记录，url转发，ns记录</a></p>
  </li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TCP/IP之IP包头部]]></title>
    <link href="http://xixitalk.github.io/blog/2016/10/10/ipheader-of-tcpip/"/>
    <updated>2016-10-10T17:03:51+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/10/10/ipheader-of-tcpip</id>
    <content type="html"><![CDATA[<p>TCP/IP之IP包头部</p>

<!--more-->

<p><img src="http://www.informit.com/content/images/chap3_0672323516/elementLinks/03table02.gif" alt="iphead" /></p>

<h3 id="ip">IP包头</h3>

<table border="1">
  <tbody>
    <tr>
      <td>4位版本</td>
      <td>4位首部长度</td>
      <td>8位服务类型</td>
      <td>16位总长度</td>
    </tr>
    <tr>
      <td>16位标识</td>
      <td>3位标志</td>
      <td>13位片偏移</td>
      <td> </td>
    </tr>
    <tr>
      <td>8位生存时间（TTL）</td>
      <td>8位协议</td>
      <td>16位首部校验和</td>
      <td> </td>
    </tr>
    <tr>
      <td>32位源IP地址</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>32位目的IP地址</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>可选字段</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>不定长度数据</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>4位版本：4表示IPv4<br />
4位首部长度：一般是5，标识首部20bytes<br />
<strong>注释： <code>08 00 45 00</code>是典型的IP包特征</strong>,08 00是以太网帧头中IP包类型标识<br />
8位服务类型：<br />
16位总长度：整个IP包长度（如果数据是UDP包，包含了UDP包的长度）<br />
8位协议：<strong>0x11是UDP，0x06是TCP</strong><br />
8位TTL：0x80（128）</p>

<h3 id="udp">UDP包头</h3>

<table border="1">
  <tbody>
    <tr>
      <td>16位源端口</td>
      <td>16位目的端口</td>
    </tr>
    <tr>
      <td>16位长度</td>
      <td>16位校验和</td>
    </tr>
  </tbody>
</table>

<p>整个UDP包头8个字节。<br />
16位长度：包括UDP头和数据包（比如上层DNS协议）</p>

<p>READ MORE<br />
<a href="http://www.informit.com/articles/article.aspx?p=28782&amp;seqNum=3">http://www.informit.com/articles/article.aspx?p=28782&amp;seqNum=3</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TCP/IP之以太网帧]]></title>
    <link href="http://xixitalk.github.io/blog/2016/10/10/Ethernet-of-tcpip/"/>
    <updated>2016-10-10T10:15:46+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/10/10/Ethernet-of-tcpip</id>
    <content type="html"><![CDATA[<h3 id="ethernet-iiv2">Ethernet II(以太网V2帧)</h3>

<!--more-->

<table border="1">
  <thead>
    <tr>
      <th>6字节</th>
      <th>6字节</th>
      <th>2字节</th>
      <th>46-1500字节</th>
      <th>4字节</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>目标MAC地址</td>
      <td>源MAC地址</td>
      <td>类型</td>
      <td>数据</td>
      <td>FCS</td>
    </tr>
  </tbody>
</table>

<p><strong>类型</strong>：  08 00 是IP包，08 06 是ARP包<br />
<strong>数据</strong>：  最常见的是IP包<br />
<strong>FCS</strong>：   Frame check sequence帧校验序列  </p>

<p>更多常见类型：  </p>

<table border="1">
  <thead>
    <tr>
      <th>类型值</th>
      <th>解释</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x0800</td>
      <td>网际协议（IP）</td>
    </tr>
    <tr>
      <td>0x0806</td>
      <td>地址解析协议（ARP ： Address Resolution Protocol）</td>
    </tr>
    <tr>
      <td>0x0808</td>
      <td>帧中继 ARP （Frame Relay ARP） [RFC1701]</td>
    </tr>
    <tr>
      <td>0x814C</td>
      <td>简单网络管理协议（SNMP：Simple Network Management Protocol）</td>
    </tr>
    <tr>
      <td>0x86DD</td>
      <td>网际协议v6 （IPv6，Internet Protocol version 6）</td>
    </tr>
    <tr>
      <td>0x880B</td>
      <td>点对点协议（PPP：Point-to-Point Protocol）</td>
    </tr>
    <tr>
      <td>0x8847</td>
      <td>多协议标签交换（单播）（MPLS：Multi-Protocol Label Switching unicast）</td>
    </tr>
    <tr>
      <td>0x8848</td>
      <td>多协议标签交换（组播）（MPLS, Multi-Protocol Label Switching multicast）</td>
    </tr>
  </tbody>
</table>

<p>More Read  <a href="http://technow.blog.51cto.com/746816/320773">http://technow.blog.51cto.com/746816/320773</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DNS在HTTP网络交互流程中的位置]]></title>
    <link href="http://xixitalk.github.io/blog/2016/10/09/http-connection/"/>
    <updated>2016-10-09T08:55:37+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/10/09/http-connection</id>
    <content type="html"><![CDATA[<p>DNS在HTTP网络交互流程中的位置</p>

<!--more-->

<p>一个简单的HTTP请求流程（C语言版）</p>

<ol>
  <li>建立socket(socket())</li>
  <li>由域名查询到IP(getaddrinfo()或者gethostbyname())</li>
  <li>建立连接(connect())</li>
  <li>按照HTTP协议要求发送数据(send())</li>
  <li>监听socket等待接收数据(select())</li>
  <li>监听到数据后接收数据(recv())</li>
  <li>按照HTTP协议解析数据，再发送数据或者结束</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[柏林警方在难民中心枪杀了一名父亲，因为他企图攻击性侵他女儿的嫌疑犯]]></title>
    <link href="http://xixitalk.github.io/blog/2016/09/30/Berlin-Police-shoot-dead-father-at-refugee-centre-as-he-attacks-man-he-accused-of-abusing-daughter/"/>
    <updated>2016-09-30T09:10:49+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/09/30/Berlin-Police-shoot-dead-father-at-refugee-centre-as-he-attacks-man-he-accused-of-abusing-daughter</id>
    <content type="html"><![CDATA[<h3 id="berlin-police-shoot-dead-father-at-refugee-centre-as-he-attacks-man-he-accused-of-abusing-daughter">Berlin Police shoot dead father at refugee centre as he attacks man he accused of abusing daughter</h3>

<!--more-->

<h4 id="section">柏林警方在难民中心枪杀了一名女孩的父亲，因为他企图攻击性侵他女儿的嫌疑犯</h4>

<p>Police said that 29-year-old was shot attempting to attack alleged abuser with a knife.</p>

<p>警方声称29岁的死者被枪击原因是他企图用刀攻击嫌疑犯。</p>

<p>By Tom Porter<br />
September 28, 2016 12:54 BST</p>

<p><a href="http://www.ibtimes.co.uk/berlin-police-shoot-dead-father-refugee-centre-he-attacks-man-he-accused-abusing-daughter-1583767">http://www.ibtimes.co.uk/berlin-police-shoot-dead-father-refugee-centre-he-attacks-man-he-accused-abusing-daughter-1583767</a></p>

<p><img src="https://d.ibtimes.co.uk/en/full/1459826/berlin-police.jpg?w=736" alt="topic" /></p>

<p>Berlin police said the man suspected of shooting dead a 31-year-old British man is on the loose </p>

<p>【另一事件2016-09-21】柏林警方声称涉嫌枪杀一名31岁英国男子的男子已经被释放</p>

<p>Berlin police shot dead a father at a refugee home as he attempted to attack a man he accused of sexually abusing his daughter.</p>

<p>柏林警方枪杀了一名父亲，他企图攻击性侵他女儿的嫌疑犯。</p>

<p>Police arrested a 27-year-old man at a refugee centre in the Moabit area of the city on Tuesday evening accused of sexually abusing an 8-year-old girl.</p>

<p>星期二的晚上，在柏林Moabit街区的难民营，警方以性侵8岁小女孩的罪名拘捕了一名27岁男子。</p>

<p>The girl’s 29-year-old father reportedly charged at the handcuffed suspect with a knife as he was being arrested and put in a police car, and officers shot him, DPA reported. The father died hours later at a hospital.</p>

<p>在这名戴着手铐嫌疑犯正被塞进警车的时候，女孩29岁的父亲持小刀企图攻击嫌疑犯，随后警方对他开枪。据德新社报道，几个小时后这名父亲在一家医院死亡。</p>

<p>Witnesses said the father shouted “You will not survive this” as he charged at the alleged abuser.</p>

<p>目击者声称这名父亲在攻击嫌疑犯的时候大喊“你去死吧”。</p>

<p>An investigation into the shooting will be carried out by Berlin’s homicide division.</p>

<p>柏林警方凶杀专案组将会对本次枪击进行一系列调查。</p>

<p>Neither the names of the man arrested nor the man killed have been released by police. Unconfirmed reports claim the alleged abuser is Pakistani.</p>

<p>警方没有公开嫌疑犯和这名被杀男子的名字。未经证实报告声称这名性侵嫌疑犯是巴基斯坦人。</p>

<p>In July, a member of the left wing Die Linke party told German parliament that there has been 128 allegations of children being sexually abused at refugee centres in the country in the first quarter of 2016.</p>

<p>七月，一名左翼党派成员告诉德国议会：2016年第一季度，难民安置中心里已经发生了128起儿童被性侵事件。</p>

<p>A four-year-old child was allegedly raped by an Afghan man at a refugee centre in Hamburg in March, a court in Kiel recently heard.</p>

<p>基尔(Kiel)法院最近审理了一个案子，一个四岁的孩子在汉堡(Hamburg)难民中心被一个阿富汗男人强奸，事件发生在三月份。</p>

<p>In 2015, more than a million refugees and immigrants entered Germany, many fleeing war and poverty in the Middle East and Africa.</p>

<p>在2015年，有超过1百万中东和非洲人因战争或贫穷的原因以难民或移民身份进入德国。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派go语言编译器安装配置]]></title>
    <link href="http://xixitalk.github.io/blog/2016/09/17/raspbian-golang-install/"/>
    <updated>2016-09-17T19:42:13+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/09/17/raspbian-golang-install</id>
    <content type="html"><![CDATA[<p>关键词：树莓派 go语言编译器安装 raspbian golang install</p>

<!--more-->

<p>目前树莓派raspbian系统上go语言编译器版本还是1.3.3，太旧了，很多go语言写的软件都编译不成功。go语言从1.6版本官方直接提供ARM版本二进制文件，树莓派上直接可以使用。</p>

<h2 id="go">go编译器下载</h2>

<p>golang语言官方下载地址：<a href="https://golang.org/dl/">https://golang.org/dl/</a></p>

<p>目前（2016.09.17）最新版是1.7.1，选择其中的ARM版本。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">go1.7.1.linux-armv6l.tar.gz	Archive	Linux	ARMv6	66MB
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>下载后在树莓派上用tar解压，比如解压路径为：<code>/home/pi/go/go1.7</code>里，<code>/home/pi/go/go1.7/go/bin/go</code>为编译器go命令。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line"> $ file /home/pi/go/go1.7/go/bin/go
</span><span class="line">/home/pi/go/go1.7/go/bin/go: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, not stripped
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><strong>编译器不用安装到系统里了，直接使用即可，后续版本更新直接替换即可</strong>。</p>

<h2 id="go-1">go编译环境配置</h2>

<p>配置go编译器环境，<code>GOROOT</code>是go编译器安装目录，<code>GOPATH</code>是代码工程所在目录。重新设置<code>PATH</code>，把下载的编译器命令加到系统原来PATH之前，替换系统旧的go编译器。最好把系统代理配置上，不然从<code>github.com</code>下载代码会失败。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">export GOROOT=/home/pi/go/go1.7/go
</span><span class="line">export GOPATH=/home/pi/go/projects
</span><span class="line">export PATH=/home/pi/go/go1.7/go/bin:$PATH
</span><span class="line">export http_proxy=http://192.168.1.106:8118
</span><span class="line">export https_proxy=http://192.168.1.106:8118
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section">编译一个软件试试</h2>

<p>从<code>github.com</code>自动下载代码编译一个工程试试，比如<a href="http://github.com/ayanamist/gdns-go">gdns-go</a></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">go get github.com/ayanamist/gdns-go
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>看看<code>/home/pi/go/projects</code>目录是不是有<code>bin</code> <code>pkg</code> <code>src</code>三个目录，<code>bin</code>目录就有编译好的<code>gdns-go</code>程序了。</p>

<h2 id="gdns-go">gdns-go推荐说明</h2>

<p>搜索关键词：gdns-go DNS dnsmasq  DNSCrypt DNS污染</p>

<p><code>gdns-go</code>是一个基于<a href="https://developers.google.com/speed/public-dns/docs/dns-over-https">Google DNS over HTTPS API</a>的DNS服务器程序，因为Google的API接口被墙，所以支持通过<a href="https://github.com/shadowsocks">shadowsocks</a>连接和socks5代理连接，带<code>Cache</code>缓存，解析速度有保障。是一个比较完美的解决DNS污染的DNS服务器。go语言实现，方便windows、linux环境和各种ARM+linux路由器设备树莓派编译运行。</p>

<p><code>config.json</code>例子配置如下，然后执行<code>sudo ./gdns-go &gt; /dev/null 2&gt;&amp;1 &amp;</code>后台运行即可(53端口需要root权限账号运行)。我已经用<code>gdns-go</code>取代<code>dnsmasq</code> + <code>DNSCrypt</code>。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">{
</span><span class="line">  "listen": "192.168.1.104:53",
</span><span class="line">  "proxy": "ss://aes-128-cfb:x123456x@17.x.x.x:15879",
</span><span class="line">  "mapping": {
</span><span class="line">    "taobao.com": "223.5.5.5"
</span><span class="line">  }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[造了一个轮子：sleep命令]]></title>
    <link href="http://xixitalk.github.io/blog/2016/09/15/sleep-linux-command/"/>
    <updated>2016-09-15T08:03:35+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/09/15/sleep-linux-command</id>
    <content type="html"><![CDATA[<p>我们一个嵌入式平台，系统是<code>uClinux</code>，不支持动态库，只能用静态库，每个程序都包含了所有调用的函数代码，包括C库的。客户一个产品压力测试时偶现系统内存不够，期望当天我们能协助他们解决，内存优化有很多方向，不好入手啊。</p>

<!--more-->

<p>通过分析内存不够的现场，系统内存还有一些，但是碎片化了，物理连续的256K的内存块都没有了。同时发现客户有两个常驻的sh进程，两个sh程序都用<code>sleep</code>做等待循环。<code>linux</code>命令用的是<code>busybox</code>，任何一个命令都是运行<code>busybox</code>。运行一个<code>busybox</code>要耗费512K内存，<code>sleep</code>命令也是这样。</p>

<p>两个<code>sleep</code>本身就占用1M，把sh脚本分拆，在代码里<code>sleep</code>，就会去掉这个内存占用，是个可以优化出一点内存的方法。但是经过沟通客户不愿意修改sh脚本，从项目考虑我也理解。后来<strong>我脑洞大开了一下，觉得<code>sleep</code>命令最后就是简单调用<code>sleep</code>函数，为何不重新实现一个，不用<code>busybox</code>的那个呢。重新实现了一个sleep命令，替换busybox里的sleep命令，这样就能减少<code>sleep</code>的内存占用了</strong>。</p>

<p>于是写了一个最简单的只有20行的<code>sleep</code>命令，不支持<code>s</code> <code>m</code> <code>h</code> <code>d</code> 参数，不支持浮点数，静态编译出来只有10K，加上默认4K栈空间，运行时候16K内存就足够了，这样就能节省出这1M内存，经过客户测试发现问题解决了。好啊，中秋节不用加班了。（备注：南京受台风影响，中秋节下了一整天雨，这篇博客就是中秋节写的。）</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
</pre></td><td class="code"><pre><code class=""><span class="line">#include &lt;stdio.h&gt;
</span><span class="line">#include &lt;stdlib.h&gt;
</span><span class="line">#include &lt;unistd.h&gt;
</span><span class="line">
</span><span class="line">int main(int argc, char *argv[])
</span><span class="line">{
</span><span class="line">    unsigned long int timelen = 0;
</span><span class="line">    int i = 0;
</span><span class="line">
</span><span class="line">    if(1 == argc)
</span><span class="line">        return -1;
</span><span class="line">
</span><span class="line">    for(i = 1; i &lt; argc; i++)
</span><span class="line">        timelen += strtoul(argv[i], NULL, 10);
</span><span class="line">
</span><span class="line">    if(timelen &gt; 0)
</span><span class="line">        sleep(timelen);
</span><span class="line">
</span><span class="line">    return 0;
</span><span class="line">}
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>后来想想还是实现一个功能比较全的吧，代码如下。和标准linux sleep命令功能唯一不同的是：没有实现浮点数支持。</p>

<script src="https://gist.github.com/xixitalk/354a2628bbd21214be5340b0cac0ac52.js"></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[产品中多个不明可执行程序dvrHelper]]></title>
    <link href="http://xixitalk.github.io/blog/2016/08/30/virus-dvrHelper/"/>
    <updated>2016-08-30T16:48:47+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/08/30/virus-dvrHelper</id>
    <content type="html"><![CDATA[<p>一个数据类产品，测试报告描述：FTP上传下载加浏览器看视频，一个小时内必死机。</p>

<p>死机现场初步分析：死机直接原因是系统内存耗尽，但是发现进程里多了三个奇怪的进程，进程名都像是随机字符串，两个死机现场都有，并且进程名还随机的不一样。</p>

<!--more-->

<p>有人去分析内存问题，我来分析三个奇怪的进程。</p>

<p>这三个进程父进程是Init，执行的命令是<code>dvrHelper</code>，开始我怀疑版本自带的程序，查看了版本编译后的文件系统，没有这个文件，在整个版本代码里搜索这个字符串，没有找到任何踪迹。这时候有人告诉我版本的根文件系统里多了<code>dvrHelper</code>文件，重烧版本是没有这个文件的。手动运行这个文件，提示</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">listening tun0
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>运行结束后，进程列表里就多了三个奇怪的进程。父进程是Init，这是linux守护进程惯用的机制。我把dvrHelper上传到<code>https://www.virustotal.com</code>在线扫描，55个杀毒软件，有2个提示异常。通常<code>VPN</code>会使用<code>tun0</code>和<code>tup0</code>这样虚拟网口，这应该是一个网络包监控/分析/过滤程序。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">SHA256:	c483618671766847fc75ea79fdc201df2e4a93f501dc98ec9c6f283fb1d4336c
</span><span class="line">File name:	dvrHelper
</span><span class="line">Detection ratio:	2 / 55
</span><span class="line">Analysis date:	2016-08-29 08:51:11 UTC ( 22 hours, 56 minutes ago )
</span><span class="line">
</span><span class="line">AVG	Linux/Fgt.CA	20160829
</span><span class="line">ESET-NOD32	a variant of Linux/Gafgyt.SE	20160829
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>通过<code>file</code>命令查看文件属性，说是ARM格式的ELF文件。反汇编没有任何调试信息，汇编上看不出功能。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ file dvrHelper
</span><span class="line">dvrHelper: ELF 32-bit LSB executable, ARM, version 1 (SYSV), statically linked, stripped
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这时候基本确认，<code>dvrHelper</code>文件是个木马程序了。引入这个木马的路径分析只有两个，一个通过<code>adb push</code>，一个就是<code>telnet</code>。</p>

<p>先禁用了<code>adb</code>功能，发现问题还是出现了。<br />
<strong>同时禁用<code>adb</code>和<code>telnetd</code>，问题不出现了</strong>。</p>

<p>现在问题聚焦在<code>telnetd</code>服务上。</p>

<p><code>telnet</code>是一个远程协议，<code>telnetd</code>是一个实现<code>telnet协议</code>的服务程序。</p>

<p>PC上用<code>wireshark</code>抓包，没有抓到PC上应用程序登录<code>telnetd</code>的证据。后来突然想到<code>pppoe</code>功能可能会分配一个公网IP，<code>ifconfig</code>一看，果然电信分配了一个公网IP。用手机登录这个公网IP的<code>telnet</code>，也果然登录到这个产品里了。这样就怀疑产品是通过公网IP登录产品的<code>telnetd</code>服务，把木马上传到产品里了。</p>

<p>同时在内核<code>fs/open.c</code>里加代码，如果打开<code>dvrHelper</code>文件就panic死机。死机显示在通过busybox执行<code>cp /bin/echo dvrHelper</code>，顺着父进程一直往上找，找到了<code>telnetd</code>进程。这样也再次排除了<code>adb</code>的嫌疑。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)
</span><span class="line">{
</span><span class="line">        if(strstr(filename,"dvrHelper"))
</span><span class="line">            panic("[testcode] dvrHelper found\n");
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>tenetd</code>是包含在<code>busybox</code>工具包里，在<code>telnetd.c</code>里增加代码，用<code>getpeername</code>获取登录客户的IP是<code>0.0.0.0</code>，不知道为什么。按说<code>accept</code>后调用<code>getpeername</code>没有问题啊。我对网络不熟，如果有人知道请赐教。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class=""><span class="line">struct sockaddr_in sa;
</span><span class="line">int len = sizeof(sa);
</span><span class="line">FILE *fp;
</span><span class="line">
</span><span class="line">/*something*/
</span><span class="line">fd = accept(master_fd, NULL, NULL);
</span><span class="line">if (fd &lt; 0)
</span><span class="line">	goto again;
</span><span class="line">close_on_exec_on(fd);
</span><span class="line">
</span><span class="line">if(!getpeername(fd, (struct sockaddr *)&amp;sa, &amp;len))
</span><span class="line">{
</span><span class="line">  fp = fopen("/cache/login.log","ab+");
</span><span class="line">  fprintf(fp,"[testcode] accept  from %s \n", inet_ntoa(sa.sin_addr));
</span><span class="line">  fclose(fp);
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这时候只好祭出了<code>tcpdump</code>工具，在产品内部运行<code>tcpdump</code>，只抓取公网网口的23端口数据包。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">tcpdump -i ppp0 port 23
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><strong>十几分钟的时间，就抓到了来自台湾 泰国 巴西 印度的<code>telnet</code>登录，再一会根目录就多了<code>dvrHelper</code>文件。</strong></p>

<p>修改意见：<br />
1. 发货版本禁用<code>telnetd</code>服务
2. 开发版本用<code>iptables</code>设置禁止<code>ppp0</code>网口的23端口访问，不用admin：admin这样简单的账号密码，<code>telnetd</code>可以不用默认23端口，换成4589这样端口号</p>

<p>PS：因特网真是太危险了</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[netlink遇到ENOBUFS错误]]></title>
    <link href="http://xixitalk.github.io/blog/2016/08/18/netlink-ENOBUFS/"/>
    <updated>2016-08-18T08:49:42+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/08/18/netlink-ENOBUFS</id>
    <content type="html"><![CDATA[<p>一个场景：USB插拔的时候内核会通过netlink广播到user层，多个应用接收这个消息。但是出现了errno 105错误，105错误是：<code>No buffer space available</code></p>

<!--more-->

<p>经过内核代码分析，<code>af_netlink.c</code>里<code>netlink_broadcast_deliver</code>函数返回-1才会触发<code>ENOBUFS</code>流程。加<code>printk</code>和<code>panic</code>复现问题(因为嵌入式开发环境抓panic死机现场分析和串口log都太方便了)。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class=""><span class="line">static int netlink_broadcast_deliver(struct sock *sk, struct sk_buff *skb)
</span><span class="line">{
</span><span class="line">	struct netlink_sock *nlk = nlk_sk(sk);
</span><span class="line">
</span><span class="line">	if (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &lt;= sk-&gt;sk_rcvbuf &amp;&amp;
</span><span class="line">	    !test_bit(0, &amp;nlk-&gt;state)) {
</span><span class="line">		skb_set_owner_r(skb, sk);
</span><span class="line">		__netlink_sendskb(sk, skb);
</span><span class="line">		return atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; (sk-&gt;sk_rcvbuf &gt;&gt; 1);
</span><span class="line">	}
</span><span class="line">	printk("[testcode]netlink sk_rmem_alloc:%x sk_rcvbuf:%x \n",atomic_read(&amp;sk-&gt;sk_rmem_alloc),sk-&gt;sk_rcvbuf);
</span><span class="line">	panic("[testcode]netlink broadcast panic\n");
</span><span class="line">	return -1;
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>抓取的串口log如下显示<code>sk_rcvbuf</code>确实小于<code>sk_rmem_alloc</code>了，没有空间了。</p>

<blockquote>
  <p>[   18.618473] [testcode]netlink sk_rmem_alloc:b00 sk_rcvbuf:8b8  [<br />
18.623727] Kernel panic - not syncing: [testcode]netlink broadcast panic</p>
</blockquote>

<p>对比发现死机现场里的<code>kobject_uevent_env</code>函数里的<code>uevent_sock</code>变量里<code>sk_sndbuf</code>和<code>sk_rcvbuf</code>都是163840（160K）。而<code>netlink_broadcast_deliver</code>里sock是8b8（2232）。很明显netlink接收socket里的sock比内核驱动的sock接收buf差距太大了。</p>

<p>内核sock.c里<code>sock_init_data</code>函数里进行sock初始化，<code>sk_rcvbuf</code>和<code>sk_sndbuf</code>初始化成<code>sysctl_rmem_default</code>。<code>sysctl_rmem_default</code>是个全局变量，导出的panic现场看值就是163840。</p>

<blockquote>
  <p>sk-&gt;sk_rcvbuf		=	sysctl_rmem_default;
sk-&gt;sk_sndbuf		=	sysctl_wmem_default;</p>
</blockquote>

<p>看应用netlink的接收，果然用<code>setsockopt</code>修改了<code>RCVBUF</code>。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class=""><span class="line">const int buffersize = 1024;  
</span><span class="line">int ret;  
</span><span class="line">
</span><span class="line">struct sockaddr_nl snl;  
</span><span class="line">bzero(&amp;snl, sizeof(struct sockaddr_nl));  
</span><span class="line">snl.nl_family = AF_NETLINK;  
</span><span class="line">snl.nl_pid = getpid();  
</span><span class="line">snl.nl_groups = 1;  
</span><span class="line">
</span><span class="line">int s = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT);  
</span><span class="line">if (s == -1)   
</span><span class="line">{  
</span><span class="line">    perror("socket");  
</span><span class="line">    return -1;  
</span><span class="line">}  
</span><span class="line">setsockopt(s, SOL_SOCKET, SO_RCVBUF, &amp;buffersize, sizeof(buffersize));  
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>C库的<code>setsockopt</code>函数会通过系统调用进入到内核<code>sock.c</code>文件里的<code>sock_setsockopt</code>函数。<code>SOCK_MIN_RCVBUF</code>就是2232。很明显应用<code>setsockopt</code>的<code>buffersize</code>是1024，乘以2还小于<code>SOCK_MIN_RCVBUF</code>，所以<code>sk_rcvbuf</code>就变成<code>SOCK_MIN_RCVBUF</code>。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">case SO_RCVBUF:
</span><span class="line">    if (val &gt; sysctl_rmem_max)
</span><span class="line">		val = sysctl_rmem_max;
</span><span class="line">	if ((val * 2) &lt; SOCK_MIN_RCVBUF)
</span><span class="line">		sk-&gt;sk_rcvbuf = SOCK_MIN_RCVBUF;
</span><span class="line">	else
</span><span class="line">		sk-&gt;sk_rcvbuf = val * 2;
</span><span class="line">	break;
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>解决办法：删除应用代码里的<code>setsockopt</code>语句,这样<code>sk_rcvbuf</code>默认就是160K，或者用<code>setsockopt</code>设置合适的大小。</p>

<p>通过Google发现，网络上好多netlink实例都用了<code>setsockopt</code>设置了1024的buffer大小。应用这个代码应该是从网上抄来的。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在内核里获取当前任务名]]></title>
    <link href="http://xixitalk.github.io/blog/2016/08/10/current-comm/"/>
    <updated>2016-08-10T08:33:02+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/08/10/current-comm</id>
    <content type="html"><![CDATA[<p>遇到一个问题，在一个内核模块里使用current-&gt;comm保存当前任务名，编译报错:<code>dereferencing pointer to incomplete type</code>。</p>

<!--more-->

<p>经过搜索发现，除了要包含<code>current.h</code>外，还要包含<code>sched.h</code>。原因是<code>struct task_struct</code>在<code>sched.h</code>里定义。<code>comm</code>是数组字符串，长度是<code>TASK_COMM_LEN</code>，一般是16个字节，记得保证足够的空间，防止内存越界。</p>

<p>用法实例如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">#include &lt;linux/sched.h&gt;
</span><span class="line">#include &lt;asm/current.h&gt;
</span><span class="line">
</span><span class="line">static char g_cfg_app_name[TASK_COMM_LEN*2] = { 0 };
</span><span class="line">
</span><span class="line">strncpy(g_cfg_app_name,current-&gt;comm,TASK_COMM_LEN);
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section">参考文章</h4>

<p><a href="http://www.xuebuyuan.com/1814455.html">http://www.xuebuyuan.com/1814455.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jemalloc add2line ligsigsegv]]></title>
    <link href="http://xixitalk.github.io/blog/2016/08/03/jemalloc-add2line-ligsigsegv/"/>
    <updated>2016-08-03T18:38:22+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/08/03/jemalloc-add2line-ligsigsegv</id>
    <content type="html"><![CDATA[<p>一些定位工具还需要研究</p>

<!--more-->

<p><a href="http://www.cnblogs.com/djinmusic/archive/2013/02/04/2891753.html">http://www.cnblogs.com/djinmusic/archive/2013/02/04/2891753.html</a></p>

<p><a href="http://blog.codingnow.com/2014/01/out_of_range_bug.html">http://blog.codingnow.com/2014/01/out_of_range_bug.html</a></p>

<p><a href="http://blog.csdn.net/olidrop/article/details/7295908">http://blog.csdn.net/olidrop/article/details/7295908</a></p>

<p><a href="https://www.gnu.org/software/libsigsegv/">https://www.gnu.org/software/libsigsegv/</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[fwrite()多了个了0x0D字符]]></title>
    <link href="http://xixitalk.github.io/blog/2016/08/02/fwrite-0x0D/"/>
    <updated>2016-08-02T08:18:55+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/08/02/fwrite-0x0D</id>
    <content type="html"><![CDATA[<p>fwrite()写文件竟然多了个了0x0D字符，buffer里检查了也确实没有0x0D，一搜索竟然是如果fopen不是二进制打开，fwrite()遇到0x0A额外写一个0x0D。0D 0A是windows平台的换行符，很明显这是只有在windows平台才有的奇特现象。</p>

<!--more-->

<p>解决办法是fopen的flag加个<code>b</code>。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">fopen("sample.bin", "w+");
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>修改成：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">fopen("sample.bin", "wb+");
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>另外想起来几年前我遇到过，也解决过，但是忘记了。这次随手记录下来。</p>

<h4 id="section">参考文章</h4>

<p><a href="http://blog.csdn.net/njuitjf/article/details/5821716">http://blog.csdn.net/njuitjf/article/details/5821716</a><br />
<a href="http://stackoverflow.com/questions/5537066/strange-0x0d-being-added-to-my-binary-file">http://stackoverflow.com/questions/5537066/strange-0x0d-being-added-to-my-binary-file</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pthread和errno]]></title>
    <link href="http://xixitalk.github.io/blog/2016/08/01/pthread-errno/"/>
    <updated>2016-08-01T19:10:02+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/08/01/pthread-errno</id>
    <content type="html"><![CDATA[<p>pthread和errno：pthread函数在出错的时候不会设置errno，而是直接返回错误值。</p>

<!--more-->

<blockquote>
  <p><strong>pthread_create() won’t ever set errno</strong>.  pthread function returns zero
on success, and an error code on error.  So the value you are seeing
in errno is either the result of an error in some previous other
system call, or errno is just starting out at EINTR and never getting
changed (this has happened to me).</p>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line"> #define handle_error_en(en, msg) \
</span><span class="line">               do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)
</span><span class="line">
</span><span class="line">s = pthread_create(&amp;tinfo[tnum].thread_id, &amp;attr,
</span><span class="line">                      &amp;thread_start, &amp;tinfo[tnum]);
</span><span class="line">if (s != 0)
</span><span class="line">    handle_error_en(s, "pthread_create");
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section">参考资料</h4>

<p><a href="http://man7.org/linux/man-pages/man3/pthread_create.3.html">http://man7.org/linux/man-pages/man3/pthread_create.3.html</a><br />
<a href="https://sourceware.org/ml/libc-alpha/2000-10/msg00153.html">https://sourceware.org/ml/libc-alpha/2000-10/msg00153.html</a><br />
<a href="http://www.oschina.net/question/234345_40365">http://www.oschina.net/question/234345_40365</a></p>

]]></content>
  </entry>
  
</feed>
