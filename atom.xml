<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[xixitalk's snippet]]></title>
  <link href="http://xixitalk.github.io/atom.xml" rel="self"/>
  <link href="http://xixitalk.github.io/"/>
  <updated>2016-10-10T10:21:02+00:00</updated>
  <id>http://xixitalk.github.io/</id>
  <author>
    <name><![CDATA[xixitalk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[TCP/IP之IP包头部]]></title>
    <link href="http://xixitalk.github.io/blog/2016/10/10/ipheader-of-tcpip/"/>
    <updated>2016-10-10T17:03:51+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/10/10/ipheader-of-tcpip</id>
    <content type="html"><![CDATA[<p>TCP/IP之IP包头部</p>

<!--more-->

<p><img src="http://www.informit.com/content/images/chap3_0672323516/elementLinks/03table02.gif" alt="iphead" /></p>

<h3 id="ip">IP包头</h3>

<table border="1">
  <tbody>
    <tr>
      <td>4位版本</td>
      <td>4位首部长度</td>
      <td>8位服务类型</td>
      <td>16位总长度</td>
    </tr>
    <tr>
      <td>16位标识</td>
      <td>3位标志</td>
      <td>13位片偏移</td>
      <td> </td>
    </tr>
    <tr>
      <td>8位生存时间（TTL）</td>
      <td>8位协议</td>
      <td>16位首部校验和</td>
      <td> </td>
    </tr>
    <tr>
      <td>32位源IP地址</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>32位目的IP地址</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>可选字段</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>不定长度数据</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>4位版本：4表示IPv4<br />
4位首部长度：一般是5，标识首部20bytes<br />
<strong>注释： <code>45</code>是典型的IP包特征</strong><br />
8位服务类型：<br />
16位总长度：整个IP包长度（如果数据是UDP包，包含了UDP包的长度）<br />
8位协议：<strong>0x11是UDP，0x06是TCP</strong><br />
8位TTL：0x80（128）</p>

<h3 id="udp">UDP包头</h3>

<table border="1">
  <tbody>
    <tr>
      <td>16位源端口</td>
      <td>16位目的端口</td>
    </tr>
    <tr>
      <td>16位长度</td>
      <td>16位校验和</td>
    </tr>
  </tbody>
</table>

<p>整个UDP包头8个字节。<br />
16位长度：包括UDP头和数据包（比如上层DNS协议）</p>

<p>READ MORE<br />
<a href="http://www.informit.com/articles/article.aspx?p=28782&amp;seqNum=3">http://www.informit.com/articles/article.aspx?p=28782&amp;seqNum=3</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TCP/IP之以太网帧]]></title>
    <link href="http://xixitalk.github.io/blog/2016/10/10/Ethernet-of-tcpip/"/>
    <updated>2016-10-10T10:15:46+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/10/10/Ethernet-of-tcpip</id>
    <content type="html"><![CDATA[<h3 id="ethernet-iiv2">Ethernet II(以太网V2帧)</h3>

<!--more-->

<table border="1">
  <thead>
    <tr>
      <th>6字节</th>
      <th>6字节</th>
      <th>2字节</th>
      <th>46-1500字节</th>
      <th>4字节</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>目标MAC地址</td>
      <td>源MAC地址</td>
      <td>类型</td>
      <td>数据</td>
      <td>FCS</td>
    </tr>
  </tbody>
</table>

<p><strong>类型</strong>：  08 00 是IP包，08 06 是ARP包<br />
<strong>数据</strong>：  最常见的是IP包<br />
<strong>FCS</strong>：   Frame check sequence帧校验序列  </p>

<p>更多常见类型：  </p>

<table border="1">
  <thead>
    <tr>
      <th>类型值</th>
      <th>解释</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x0800</td>
      <td>网际协议（IP）</td>
    </tr>
    <tr>
      <td>0x0806</td>
      <td>地址解析协议（ARP ： Address Resolution Protocol）</td>
    </tr>
    <tr>
      <td>0x0808</td>
      <td>帧中继 ARP （Frame Relay ARP） [RFC1701]</td>
    </tr>
    <tr>
      <td>0x814C</td>
      <td>简单网络管理协议（SNMP：Simple Network Management Protocol）</td>
    </tr>
    <tr>
      <td>0x86DD</td>
      <td>网际协议v6 （IPv6，Internet Protocol version 6）</td>
    </tr>
    <tr>
      <td>0x880B</td>
      <td>点对点协议（PPP：Point-to-Point Protocol）</td>
    </tr>
    <tr>
      <td>0x8847</td>
      <td>多协议标签交换（单播）（MPLS：Multi-Protocol Label Switching unicast）</td>
    </tr>
    <tr>
      <td>0x8848</td>
      <td>多协议标签交换（组播）（MPLS, Multi-Protocol Label Switching multicast）</td>
    </tr>
  </tbody>
</table>

<p>More Read  <a href="http://technow.blog.51cto.com/746816/320773">http://technow.blog.51cto.com/746816/320773</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DNS在HTTP网络交互流程中的位置]]></title>
    <link href="http://xixitalk.github.io/blog/2016/10/09/http-connection/"/>
    <updated>2016-10-09T08:55:37+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/10/09/http-connection</id>
    <content type="html"><![CDATA[<p>DNS在HTTP网络交互流程中的位置</p>

<!--more-->

<p>一个简单的HTTP请求流程（C语言版）</p>

<ol>
  <li>建立socket(socket())</li>
  <li>由域名查询到IP(getaddrinfo()或者gethostbyname())</li>
  <li>建立连接(connect())</li>
  <li>按照HTTP协议要求发送数据(send())</li>
  <li>监听socket等待接收数据(select())</li>
  <li>监听到数据后接收数据(recv())</li>
  <li>按照HTTP协议解析数据，再发生数据或者结束</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[柏林警方在难民中心枪杀了一名父亲，因为他企图攻击性侵他女儿的嫌疑犯]]></title>
    <link href="http://xixitalk.github.io/blog/2016/09/30/Berlin-Police-shoot-dead-father-at-refugee-centre-as-he-attacks-man-he-accused-of-abusing-daughter/"/>
    <updated>2016-09-30T09:10:49+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/09/30/Berlin-Police-shoot-dead-father-at-refugee-centre-as-he-attacks-man-he-accused-of-abusing-daughter</id>
    <content type="html"><![CDATA[<h3 id="berlin-police-shoot-dead-father-at-refugee-centre-as-he-attacks-man-he-accused-of-abusing-daughter">Berlin Police shoot dead father at refugee centre as he attacks man he accused of abusing daughter</h3>

<!--more-->

<h4 id="section">柏林警方在难民中心枪杀了一名女孩的父亲，因为他企图攻击性侵他女儿的嫌疑犯</h4>

<p>Police said that 29-year-old was shot attempting to attack alleged abuser with a knife.</p>

<p>警方声称29岁的死者被枪击原因是他企图用刀攻击嫌疑犯。</p>

<p>By Tom Porter<br />
September 28, 2016 12:54 BST</p>

<p><a href="http://www.ibtimes.co.uk/berlin-police-shoot-dead-father-refugee-centre-he-attacks-man-he-accused-abusing-daughter-1583767">http://www.ibtimes.co.uk/berlin-police-shoot-dead-father-refugee-centre-he-attacks-man-he-accused-abusing-daughter-1583767</a></p>

<p><img src="https://d.ibtimes.co.uk/en/full/1459826/berlin-police.jpg?w=736" alt="topic" /></p>

<p>Berlin police said the man suspected of shooting dead a 31-year-old British man is on the loose </p>

<p>【另一事件2016-09-21】柏林警方声称涉嫌枪杀一名31岁英国男子的男子已经被释放</p>

<p>Berlin police shot dead a father at a refugee home as he attempted to attack a man he accused of sexually abusing his daughter.</p>

<p>柏林警方枪杀了一名父亲，他企图攻击性侵他女儿的嫌疑犯。</p>

<p>Police arrested a 27-year-old man at a refugee centre in the Moabit area of the city on Tuesday evening accused of sexually abusing an 8-year-old girl.</p>

<p>星期二的晚上，在柏林Moabit街区的难民营，警方以性侵8岁小女孩的罪名拘捕了一名27岁男子。</p>

<p>The girl’s 29-year-old father reportedly charged at the handcuffed suspect with a knife as he was being arrested and put in a police car, and officers shot him, DPA reported. The father died hours later at a hospital.</p>

<p>在这名戴着手铐嫌疑犯正被塞进警车的时候，女孩29岁的父亲持小刀企图攻击嫌疑犯，随后警方对他开枪。据德新社报道，几个小时后这名父亲在一家医院死亡。</p>

<p>Witnesses said the father shouted “You will not survive this” as he charged at the alleged abuser.</p>

<p>目击者声称这名父亲在攻击嫌疑犯的时候大喊“你去死吧”。</p>

<p>An investigation into the shooting will be carried out by Berlin’s homicide division.</p>

<p>柏林警方凶杀专案组将会对本次枪击进行一系列调查。</p>

<p>Neither the names of the man arrested nor the man killed have been released by police. Unconfirmed reports claim the alleged abuser is Pakistani.</p>

<p>警方没有公开嫌疑犯和这名被杀男子的名字。未经证实报告声称这名性侵嫌疑犯是巴基斯坦人。</p>

<p>In July, a member of the left wing Die Linke party told German parliament that there has been 128 allegations of children being sexually abused at refugee centres in the country in the first quarter of 2016.</p>

<p>七月，一名左翼党派成员告诉德国议会：2016年第一季度，难民安置中心里已经发生了128起儿童被性侵事件。</p>

<p>A four-year-old child was allegedly raped by an Afghan man at a refugee centre in Hamburg in March, a court in Kiel recently heard.</p>

<p>基尔(Kiel)法院最近审理了一个案子，一个四岁的孩子在汉堡(Hamburg)难民中心被一个阿富汗男人强奸，事件发生在三月份。</p>

<p>In 2015, more than a million refugees and immigrants entered Germany, many fleeing war and poverty in the Middle East and Africa.</p>

<p>在2015年，有超过1百万中东和非洲人因战争或贫穷的原因以难民或移民身份进入德国。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派go语言编译器安装配置]]></title>
    <link href="http://xixitalk.github.io/blog/2016/09/17/raspbian-golang-install/"/>
    <updated>2016-09-17T19:42:13+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/09/17/raspbian-golang-install</id>
    <content type="html"><![CDATA[<p>关键词：树莓派 go语言编译器安装 raspbian golang install</p>

<!--more-->

<p>目前树莓派raspbian系统上go语言编译器版本还是1.3.3，太旧了，很多go语言写的软件都编译不成功。go语言从1.6版本官方直接提供ARM版本二进制文件，树莓派上直接可以使用。</p>

<h2 id="go">go编译器下载</h2>

<p>golang语言官方下载地址：<a href="https://golang.org/dl/">https://golang.org/dl/</a></p>

<p>目前（2016.09.17）最新版是1.7.1，选择其中的ARM版本。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">go1.7.1.linux-armv6l.tar.gz	Archive	Linux	ARMv6	66MB
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>下载后在树莓派上用tar解压，比如解压路径为：<code>/home/pi/go/go1.7</code>里，<code>/home/pi/go/go1.7/go/bin/go</code>为编译器go命令。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line"> $ file /home/pi/go/go1.7/go/bin/go
</span><span class="line">/home/pi/go/go1.7/go/bin/go: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, not stripped
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><strong>编译器不用安装到系统里了，直接使用即可，后续版本更新直接替换即可</strong>。</p>

<h2 id="go-1">go编译环境配置</h2>

<p>配置go编译器环境，<code>GOROOT</code>是go编译器安装目录，<code>GOPATH</code>是代码工程所在目录。重新设置<code>PATH</code>，把下载的编译器命令加到系统原来PATH之前，替换系统旧的go编译器。最好把系统代理配置上，不然从<code>github.com</code>下载代码会失败。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">export GOROOT=/home/pi/go/go1.7/go
</span><span class="line">export GOPATH=/home/pi/go/projects
</span><span class="line">export PATH=/home/pi/go/go1.7/go/bin:$PATH
</span><span class="line">export http_proxy=http://192.168.1.106:8118
</span><span class="line">export https_proxy=http://192.168.1.106:8118
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section">编译一个软件试试</h2>

<p>从<code>github.com</code>自动下载代码编译一个工程试试，比如<a href="http://github.com/ayanamist/gdns-go">gdns-go</a></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">go get github.com/ayanamist/gdns-go
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>看看<code>/home/pi/go/projects</code>目录是不是有<code>bin</code> <code>pkg</code> <code>src</code>三个目录，<code>bin</code>目录就有编译好的<code>gdns-go</code>程序了。</p>

<h2 id="gdns-go">gdns-go推荐说明</h2>

<p>搜索关键词：gdns-go DNS dnsmasq  DNSCrypt DNS污染</p>

<p><code>gdns-go</code>是一个基于<a href="https://developers.google.com/speed/public-dns/docs/dns-over-https">Google DNS over HTTPS API</a>的DNS服务器程序，因为Google的API接口被墙，所以支持通过<a href="https://github.com/shadowsocks">shadowsocks</a>连接和socks5代理连接，带<code>Cache</code>缓存，解析速度有保障。是一个比较完美的解决DNS污染的DNS服务器。go语言实现，方便windows、linux环境和各种ARM+linux路由器设备树莓派编译运行。</p>

<p><code>config.json</code>例子配置如下，然后执行<code>sudo ./gdns-go &gt; /dev/null 2&gt;&amp;1 &amp;</code>后台运行即可(53端口需要root权限账号运行)。我已经用<code>gdns-go</code>取代<code>dnsmasq</code> + <code>DNSCrypt</code>。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">{
</span><span class="line">  "listen": "192.168.1.104:53",
</span><span class="line">  "proxy": "ss://aes-128-cfb:x123456x@17.x.x.x:15879",
</span><span class="line">  "mapping": {
</span><span class="line">    "taobao.com": "223.5.5.5"
</span><span class="line">  }
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[造了一个轮子：sleep命令]]></title>
    <link href="http://xixitalk.github.io/blog/2016/09/15/sleep-linux-command/"/>
    <updated>2016-09-15T08:03:35+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/09/15/sleep-linux-command</id>
    <content type="html"><![CDATA[<p>我们一个嵌入式平台，系统是<code>uClinux</code>，不支持动态库，只能用静态库，每个程序都包含了所有调用的函数代码，包括C库的。客户一个产品压力测试时偶现系统内存不够，期望当天我们能协助他们解决，内存优化有很多方向，不好入手啊。</p>

<!--more-->

<p>通过分析内存不够的现场，系统内存还有一些，但是碎片化了，物理连续的256K的内存块都没有了。同时发现客户有两个常驻的sh进程，两个sh程序都用<code>sleep</code>做等待循环。<code>linux</code>命令用的是<code>busybox</code>，任何一个命令都是运行<code>busybox</code>。运行一个<code>busybox</code>要耗费512K内存，<code>sleep</code>命令也是这样。</p>

<p>两个<code>sleep</code>本身就占用1M，把sh脚本分拆，在代码里<code>sleep</code>，就会去掉这个内存占用，是个可以优化出一点内存的方法。但是经过沟通客户不愿意修改sh脚本，从项目考虑我也理解。后来<strong>我脑洞大开了一下，觉得<code>sleep</code>命令最后就是简单调用<code>sleep</code>函数，为何不重新实现一个，不用<code>busybox</code>的那个呢。重新实现了一个sleep命令，替换busybox里的sleep命令，这样就能减少<code>sleep</code>的内存占用了</strong>。</p>

<p>于是写了一个最简单的只有20行的<code>sleep</code>命令，不支持<code>s</code> <code>m</code> <code>h</code> <code>d</code> 参数，不支持浮点数，静态编译出来只有10K，加上默认4K栈空间，运行时候16K内存就足够了，这样就能节省出这1M内存，经过客户测试发现问题解决了。好啊，中秋节不用加班了。（备注：南京受台风影响，中秋节下了一整天雨，这篇博客就是中秋节写的。）</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
</pre></td><td class="code"><pre><code class=""><span class="line">#include &lt;stdio.h&gt;
</span><span class="line">#include &lt;stdlib.h&gt;
</span><span class="line">#include &lt;unistd.h&gt;
</span><span class="line">
</span><span class="line">int main(int argc, char *argv[])
</span><span class="line">{
</span><span class="line">    unsigned long int timelen = 0;
</span><span class="line">    int i = 0;
</span><span class="line">
</span><span class="line">    if(1 == argc)
</span><span class="line">        return -1;
</span><span class="line">
</span><span class="line">    for(i = 1; i &lt; argc; i++)
</span><span class="line">        timelen += strtoul(argv[i], NULL, 10);
</span><span class="line">
</span><span class="line">    if(timelen &gt; 0)
</span><span class="line">        sleep(timelen);
</span><span class="line">
</span><span class="line">    return 0;
</span><span class="line">}
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>后来想想还是实现一个功能比较全的吧，代码如下。和标准linux sleep命令功能唯一不同的是：没有实现浮点数支持。</p>

<script src="https://gist.github.com/xixitalk/354a2628bbd21214be5340b0cac0ac52.js"></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[产品中多个不明可执行程序dvrHelper]]></title>
    <link href="http://xixitalk.github.io/blog/2016/08/30/virus-dvrHelper/"/>
    <updated>2016-08-30T16:48:47+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/08/30/virus-dvrHelper</id>
    <content type="html"><![CDATA[<p>一个数据类产品，测试报告描述：FTP上传下载加浏览器看视频，一个小时内必死机。</p>

<p>死机现场初步分析：死机直接原因是系统内存耗尽，但是发现进程里多了三个奇怪的进程，进程名都像是随机字符串，两个死机现场都有，并且进程名还随机的不一样。</p>

<!--more-->

<p>有人去分析内存问题，我来分析三个奇怪的进程。</p>

<p>这三个进程父进程是Init，执行的命令是<code>dvrHelper</code>，开始我怀疑版本自带的程序，查看了版本编译后的文件系统，没有这个文件，在整个版本代码里搜索这个字符串，没有找到任何踪迹。这时候有人告诉我版本的根文件系统里多了<code>dvrHelper</code>文件，重烧版本是没有这个文件的。手动运行这个文件，提示</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">listening tun0
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>运行结束后，进程列表里就多了三个奇怪的进程。父进程是Init，这是linux守护进程惯用的机制。我把dvrHelper上传到<code>https://www.virustotal.com</code>在线扫描，55个杀毒软件，有2个提示异常。通常<code>VPN</code>会使用<code>tun0</code>和<code>tup0</code>这样虚拟网口，这应该是一个网络包监控/分析/过滤程序。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">SHA256:	c483618671766847fc75ea79fdc201df2e4a93f501dc98ec9c6f283fb1d4336c
</span><span class="line">File name:	dvrHelper
</span><span class="line">Detection ratio:	2 / 55
</span><span class="line">Analysis date:	2016-08-29 08:51:11 UTC ( 22 hours, 56 minutes ago )
</span><span class="line">
</span><span class="line">AVG	Linux/Fgt.CA	20160829
</span><span class="line">ESET-NOD32	a variant of Linux/Gafgyt.SE	20160829
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>通过<code>file</code>命令查看文件属性，说是ARM格式的ELF文件。反汇编没有任何调试信息，汇编上看不出功能。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ file dvrHelper
</span><span class="line">dvrHelper: ELF 32-bit LSB executable, ARM, version 1 (SYSV), statically linked, stripped
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这时候基本确认，<code>dvrHelper</code>文件是个木马程序了。引入这个木马的路径分析只有两个，一个通过<code>adb push</code>，一个就是<code>telnet</code>。</p>

<p>先禁用了<code>adb</code>功能，发现问题还是出现了。<br />
<strong>同时禁用<code>adb</code>和<code>telnetd</code>，问题不出现了</strong>。</p>

<p>现在问题聚焦在<code>telnetd</code>服务上。</p>

<p><code>telnet</code>是一个远程协议，<code>telnetd</code>是一个实现<code>telnet协议</code>的服务程序。</p>

<p>PC上用<code>wireshark</code>抓包，没有抓到PC上应用程序登录<code>telnetd</code>的证据。后来突然想到<code>pppoe</code>功能可能会分配一个公网IP，<code>ifconfig</code>一看，果然电信分配了一个公网IP。用手机登录这个公网IP的<code>telnet</code>，也果然登录到这个产品里了。这样就怀疑产品是通过公网IP登录产品的<code>telnetd</code>服务，把木马上传到产品里了。</p>

<p>同时在内核<code>fs/open.c</code>里加代码，如果打开<code>dvrHelper</code>文件就panic死机。死机显示在通过busybox执行<code>cp /bin/echo dvrHelper</code>，顺着父进程一直往上找，找到了<code>telnetd</code>进程。这样也再次排除了<code>adb</code>的嫌疑。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)
</span><span class="line">{
</span><span class="line">        if(strstr(filename,"dvrHelper"))
</span><span class="line">            panic("[testcode] dvrHelper found\n");
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>tenetd</code>是包含在<code>busybox</code>工具包里，在<code>telnetd.c</code>里增加代码，用<code>getpeername</code>获取登录客户的IP是<code>0.0.0.0</code>，不知道为什么。按说<code>accept</code>后调用<code>getpeername</code>没有问题啊。我对网络不熟，如果有人知道请赐教。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class=""><span class="line">struct sockaddr_in sa;
</span><span class="line">int len = sizeof(sa);
</span><span class="line">FILE *fp;
</span><span class="line">
</span><span class="line">/*something*/
</span><span class="line">fd = accept(master_fd, NULL, NULL);
</span><span class="line">if (fd &lt; 0)
</span><span class="line">	goto again;
</span><span class="line">close_on_exec_on(fd);
</span><span class="line">
</span><span class="line">if(!getpeername(fd, (struct sockaddr *)&amp;sa, &amp;len))
</span><span class="line">{
</span><span class="line">  fp = fopen("/cache/login.log","ab+");
</span><span class="line">  fprintf(fp,"[testcode] accept  from %s \n", inet_ntoa(sa.sin_addr));
</span><span class="line">  fclose(fp);
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这时候只好祭出了<code>tcpdump</code>工具，在产品内部运行<code>tcpdump</code>，只抓取公网网口的23端口数据包。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">tcpdump -i ppp0 port 23
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><strong>十几分钟的时间，就抓到了来自台湾 泰国 巴西 印度的<code>telnet</code>登录，再一会根目录就多了<code>dvrHelper</code>文件。</strong></p>

<p>修改意见：<br />
1. 发货版本禁用<code>telnetd</code>服务
2. 开发版本用<code>iptables</code>设置禁止<code>ppp0</code>网口的23端口访问，不用admin：admin这样简单的账号密码，<code>telnetd</code>可以不用默认23端口，换成4589这样端口号</p>

<p>PS：因特网真是太危险了</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[netlink遇到ENOBUFS错误]]></title>
    <link href="http://xixitalk.github.io/blog/2016/08/18/netlink-ENOBUFS/"/>
    <updated>2016-08-18T08:49:42+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/08/18/netlink-ENOBUFS</id>
    <content type="html"><![CDATA[<p>一个场景：USB插拔的时候内核会通过netlink广播到user层，多个应用接收这个消息。但是出现了errno 105错误，105错误是：<code>No buffer space available</code></p>

<!--more-->

<p>经过内核代码分析，<code>af_netlink.c</code>里<code>netlink_broadcast_deliver</code>函数返回-1才会触发<code>ENOBUFS</code>流程。加<code>printk</code>和<code>panic</code>复现问题(因为嵌入式开发环境抓panic死机现场分析和串口log都太方便了)。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class=""><span class="line">static int netlink_broadcast_deliver(struct sock *sk, struct sk_buff *skb)
</span><span class="line">{
</span><span class="line">	struct netlink_sock *nlk = nlk_sk(sk);
</span><span class="line">
</span><span class="line">	if (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &lt;= sk-&gt;sk_rcvbuf &amp;&amp;
</span><span class="line">	    !test_bit(0, &amp;nlk-&gt;state)) {
</span><span class="line">		skb_set_owner_r(skb, sk);
</span><span class="line">		__netlink_sendskb(sk, skb);
</span><span class="line">		return atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; (sk-&gt;sk_rcvbuf &gt;&gt; 1);
</span><span class="line">	}
</span><span class="line">	printk("[testcode]netlink sk_rmem_alloc:%x sk_rcvbuf:%x \n",atomic_read(&amp;sk-&gt;sk_rmem_alloc),sk-&gt;sk_rcvbuf);
</span><span class="line">	panic("[testcode]netlink broadcast panic\n");
</span><span class="line">	return -1;
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>抓取的串口log如下显示<code>sk_rcvbuf</code>确实小于<code>sk_rmem_alloc</code>了，没有空间了。</p>

<blockquote>
  <p>[   18.618473] [testcode]netlink sk_rmem_alloc:b00 sk_rcvbuf:8b8  [<br />
18.623727] Kernel panic - not syncing: [testcode]netlink broadcast panic</p>
</blockquote>

<p>对比发现死机现场里的<code>kobject_uevent_env</code>函数里的<code>uevent_sock</code>变量里<code>sk_sndbuf</code>和<code>sk_rcvbuf</code>都是163840（160K）。而<code>netlink_broadcast_deliver</code>里sock是8b8（2232）。很明显netlink接收socket里的sock比内核驱动的sock接收buf差距太大了。</p>

<p>内核sock.c里<code>sock_init_data</code>函数里进行sock初始化，<code>sk_rcvbuf</code>和<code>sk_sndbuf</code>初始化成<code>sysctl_rmem_default</code>。<code>sysctl_rmem_default</code>是个全局变量，导出的panic现场看值就是163840。</p>

<blockquote>
  <p>sk-&gt;sk_rcvbuf		=	sysctl_rmem_default;
sk-&gt;sk_sndbuf		=	sysctl_wmem_default;</p>
</blockquote>

<p>看应用netlink的接收，果然用<code>setsockopt</code>修改了<code>RCVBUF</code>。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class=""><span class="line">const int buffersize = 1024;  
</span><span class="line">int ret;  
</span><span class="line">
</span><span class="line">struct sockaddr_nl snl;  
</span><span class="line">bzero(&amp;snl, sizeof(struct sockaddr_nl));  
</span><span class="line">snl.nl_family = AF_NETLINK;  
</span><span class="line">snl.nl_pid = getpid();  
</span><span class="line">snl.nl_groups = 1;  
</span><span class="line">
</span><span class="line">int s = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT);  
</span><span class="line">if (s == -1)   
</span><span class="line">{  
</span><span class="line">    perror("socket");  
</span><span class="line">    return -1;  
</span><span class="line">}  
</span><span class="line">setsockopt(s, SOL_SOCKET, SO_RCVBUF, &amp;buffersize, sizeof(buffersize));  
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>C库的<code>setsockopt</code>函数会通过系统调用进入到内核<code>sock.c</code>文件里的<code>sock_setsockopt</code>函数。<code>SOCK_MIN_RCVBUF</code>就是2232。很明显应用<code>setsockopt</code>的<code>buffersize</code>是1024，乘以2还小于<code>SOCK_MIN_RCVBUF</code>，所以<code>sk_rcvbuf</code>就变成<code>SOCK_MIN_RCVBUF</code>。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">case SO_RCVBUF:
</span><span class="line">    if (val &gt; sysctl_rmem_max)
</span><span class="line">		val = sysctl_rmem_max;
</span><span class="line">	if ((val * 2) &lt; SOCK_MIN_RCVBUF)
</span><span class="line">		sk-&gt;sk_rcvbuf = SOCK_MIN_RCVBUF;
</span><span class="line">	else
</span><span class="line">		sk-&gt;sk_rcvbuf = val * 2;
</span><span class="line">	break;
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>解决办法：删除应用代码里的<code>setsockopt</code>语句,这样<code>sk_rcvbuf</code>默认就是160K，或者用<code>setsockopt</code>设置合适的大小。</p>

<p>通过Google发现，网络上好多netlink实例都用了<code>setsockopt</code>设置了1024的buffer大小。应用这个代码应该是从网上抄来的。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在内核里获取当前任务名]]></title>
    <link href="http://xixitalk.github.io/blog/2016/08/10/current-comm/"/>
    <updated>2016-08-10T08:33:02+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/08/10/current-comm</id>
    <content type="html"><![CDATA[<p>遇到一个问题，在一个内核模块里使用current-&gt;comm保存当前任务名，编译报错:<code>dereferencing pointer to incomplete type</code>。</p>

<!--more-->

<p>经过搜索发现，除了要包含<code>current.h</code>外，还要包含<code>sched.h</code>。原因是<code>struct task_struct</code>在<code>sched.h</code>里定义。<code>comm</code>是数组字符串，长度是<code>TASK_COMM_LEN</code>，一般是16个字节，记得保证足够的空间，防止内存越界。</p>

<p>用法实例如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">#include &lt;linux/sched.h&gt;
</span><span class="line">#include &lt;asm/current.h&gt;
</span><span class="line">
</span><span class="line">static char g_cfg_app_name[TASK_COMM_LEN*2] = { 0 };
</span><span class="line">
</span><span class="line">strncpy(g_cfg_app_name,current-&gt;comm,TASK_COMM_LEN);
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section">参考文章</h4>

<p><a href="http://www.xuebuyuan.com/1814455.html">http://www.xuebuyuan.com/1814455.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jemalloc add2line ligsigsegv]]></title>
    <link href="http://xixitalk.github.io/blog/2016/08/03/jemalloc-add2line-ligsigsegv/"/>
    <updated>2016-08-03T18:38:22+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/08/03/jemalloc-add2line-ligsigsegv</id>
    <content type="html"><![CDATA[<p>一些定位工具还需要研究</p>

<!--more-->

<p><a href="http://www.cnblogs.com/djinmusic/archive/2013/02/04/2891753.html">http://www.cnblogs.com/djinmusic/archive/2013/02/04/2891753.html</a></p>

<p><a href="http://blog.codingnow.com/2014/01/out_of_range_bug.html">http://blog.codingnow.com/2014/01/out_of_range_bug.html</a></p>

<p><a href="http://blog.csdn.net/olidrop/article/details/7295908">http://blog.csdn.net/olidrop/article/details/7295908</a></p>

<p><a href="https://www.gnu.org/software/libsigsegv/">https://www.gnu.org/software/libsigsegv/</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[fwrite()多了个了0x0D字符]]></title>
    <link href="http://xixitalk.github.io/blog/2016/08/02/fwrite-0x0D/"/>
    <updated>2016-08-02T08:18:55+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/08/02/fwrite-0x0D</id>
    <content type="html"><![CDATA[<p>fwrite()写文件竟然多了个了0x0D字符，buffer里检查了也确实没有0x0D，一搜索竟然是如果fopen不是二进制打开，fwrite()遇到0x0A额外写一个0x0D。0D 0A是windows平台的换行符，很明显这是只有在windows平台才有的奇特现象。</p>

<!--more-->

<p>解决办法是fopen的flag加个<code>b</code>。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">fopen("sample.bin", "w+");
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>修改成：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">fopen("sample.bin", "wb+");
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>另外想起来几年前我遇到过，也解决过，但是忘记了。这次随手记录下来。</p>

<h4 id="section">参考文章</h4>

<p><a href="http://blog.csdn.net/njuitjf/article/details/5821716">http://blog.csdn.net/njuitjf/article/details/5821716</a><br />
<a href="http://stackoverflow.com/questions/5537066/strange-0x0d-being-added-to-my-binary-file">http://stackoverflow.com/questions/5537066/strange-0x0d-being-added-to-my-binary-file</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pthread和errno]]></title>
    <link href="http://xixitalk.github.io/blog/2016/08/01/pthread-errno/"/>
    <updated>2016-08-01T19:10:02+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/08/01/pthread-errno</id>
    <content type="html"><![CDATA[<p>pthread和errno：pthread函数在出错的时候不会设置errno，而是直接返回错误值。</p>

<!--more-->

<blockquote>
  <p><strong>pthread_create() won’t ever set errno</strong>.  pthread function returns zero
on success, and an error code on error.  So the value you are seeing
in errno is either the result of an error in some previous other
system call, or errno is just starting out at EINTR and never getting
changed (this has happened to me).</p>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line"> #define handle_error_en(en, msg) \
</span><span class="line">               do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)
</span><span class="line">
</span><span class="line">s = pthread_create(&amp;tinfo[tnum].thread_id, &amp;attr,
</span><span class="line">                      &amp;thread_start, &amp;tinfo[tnum]);
</span><span class="line">if (s != 0)
</span><span class="line">    handle_error_en(s, "pthread_create");
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section">参考资料</h4>

<p><a href="http://man7.org/linux/man-pages/man3/pthread_create.3.html">http://man7.org/linux/man-pages/man3/pthread_create.3.html</a><br />
<a href="https://sourceware.org/ml/libc-alpha/2000-10/msg00153.html">https://sourceware.org/ml/libc-alpha/2000-10/msg00153.html</a><br />
<a href="http://www.oschina.net/question/234345_40365">http://www.oschina.net/question/234345_40365</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C库线程安全函数]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/31/Thread-safe-C-library-functions/"/>
    <updated>2016-07-31T08:28:21+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/31/Thread-safe-C-library-functions</id>
    <content type="html"><![CDATA[<p>C库线程安全函数和不安全函数</p>

<!--more-->

<p><a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0492c/Chdiedfe.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0492c/Chdiedfe.html</a></p>

<p>线程安全函数</p>

<table>
  <thead>
    <tr>
      <th>Functions</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>calloc(),free(),malloc(),realloc()</td>
      <td>The heap functions are thread-safe if the <em>mutex</em>* functions are implemented.A single heap is shared between all threads, and mutexes are used to avoid data corruption when there is concurrent access. Each heap implementation is responsible for doing its own locking. If you supply your own allocator, it must also do its own locking. This enables it to do fine-grained locking if required, rather than protecting the entire heap with a single mutex (coarse-grained locking).</td>
    </tr>
    <tr>
      <td>alloca()</td>
      <td>alloca() is thread-safe because it allocates memory on the stack.</td>
    </tr>
    <tr>
      <td>abort(),raise(),signal(),fenv.h</td>
      <td>The ARM signal handling functions and floating-point exception traps are thread-safe.The settings for signal handlers and floating-point traps are global across the entire process and are protected by locks. Data corruption does not occur if multiple threads call signal() or an fenv.h function at the same time. However, be aware that the effects of the call act on all threads and not only on the calling thread.</td>
    </tr>
    <tr>
      <td>clearerr(), fclose(),feof(),ferror(), fflush(),fgetc(),fgetpos(), fgets(),fopen(),fputc(), fputs(),fread(),freopen(), fseek(),fsetpos(),ftell(), fwrite(),getc(),getchar(), gets(),perror(),putc(), putchar(),puts(),rewind(), setbuf(),setvbuf(),tmpfile(), tmpnam(),ungetc()</td>
      <td>The stdio library is thread-safe if the <em>mutex</em>* functions are implemented.Each individual stream is protected by a lock, so two threads can each open their own stdio stream and use it, without interfering with one another.If two threads both want to read or write the same stream, locking at the fgetc() and fputc() level prevents data corruption, but it is possible that the individual characters output by each thread might be interleaved in a confusing way. <strong>Note</strong> tmpnam() also contains a static buffer but this is only used if the argument is NULL. To ensure that your use of tmpnam() is thread-safe, supply your own buffer space.</td>
    </tr>
    <tr>
      <td>fprintf(), printf(),vfprintf(), vprintf(), fscanf(),scanf()</td>
      <td>When using these functions:the standard C printf() and scanf() functions use stdio so they are thread-safe. the standard C printf() function is susceptible to changes in the locale settings if called in a multithreaded program.</td>
    </tr>
    <tr>
      <td>clock()</td>
      <td>clock() contains static data that is written once at program startup and then only ever read. Therefore, clock() is thread-safe provided no extra threads are already running at the time that the library is initialized.</td>
    </tr>
    <tr>
      <td>errno</td>
      <td>errno is thread-safe.Each thread has its own errno stored in a __user_perthread_libspace block. This means that each thread can call errno-setting functions independently and then check errno afterwards without interference from other threads.</td>
    </tr>
    <tr>
      <td>atexit()</td>
      <td>The list of exit functions maintained by atexit() is process-global and protected by a lock.In the worst case, if more than one thread calls atexit(), the order that exit functions are called cannot be guaranteed.</td>
    </tr>
    <tr>
      <td>abs(), acos(), asin(),atan(),atan2(), atof(),atol(), atoi(),bsearch(),ceil(), cos(),cosh(),difftime(), div(),exp(),fabs(), floor(),fmod(),frexp(), labs(),ldexp(),ldiv(), log(),log10(),memchr(), memcmp(),memcpy(),memmove(), memset(),mktime(),modf(), pow(),qsort(),sin(), sinh(),sqrt(),strcat(), strchr(),strcmp(),strcpy(), strcspn(),strlcat(),strlcpy(), strlen(),strncat(),strncmp(), strncpy(),strpbrk(),strrchr(), strspn(),strstr(),strxfrm(), tan(), tanh()</td>
      <td>These functions are inherently thread-safe.</td>
    </tr>
    <tr>
      <td>longjmp(), setjmp()</td>
      <td>Although setjmp() and longjmp() keep data in <em>_user_libspace, they call the __alloca</em>* functions, that are thread-safe.</td>
    </tr>
    <tr>
      <td>remove(), rename(), time()</td>
      <td>These functions use interrupts that communicate with the ARM debugging environments. Typically, you have to reimplement these for a real-world application.</td>
    </tr>
    <tr>
      <td>snprintf(), sprintf(),vsnprintf(),vsprintf(), sscanf(),isalnum(),isalpha(), iscntrl(),isdigit(),isgraph(), islower(),isprint(),ispunct(), isspace(),isupper(),isxdigit(), tolower(),toupper(),strcoll(), strtod(),strtol(),strtoul(), strftime()</td>
      <td>When using these functions, the string-based functions read the locale settings. Typically, they are thread-safe. However, if you change locale in mid-session, you must ensure that these functions are not affected.The string-based functions, such as sprintf() and sscanf(), do not depend on the stdio library.</td>
    </tr>
    <tr>
      <td>stdin, stdout, stderr</td>
      <td>These functions are thread-safe.</td>
    </tr>
  </tbody>
</table>

<p>线程不安全函数</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux内核代码瘦身]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/20/linux-kernel-source-strip/"/>
    <updated>2016-07-20T21:07:23+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/20/linux-kernel-source-strip</id>
    <content type="html"><![CDATA[<p>linux内核代码瘦身，原理：把不参与编译的代码删除，这样用Source Insight工具阅读代码的时候就轻简了很多。</p>

<p>例子数据：原本一个嵌入式linux内核代码1万7千个C文件，精简之后只有1222个C文件，删除了1万6千个C文件。</p>

<!--more-->

<h4 id="section">第一步 清理临时文件</h4>

<p>内核编译clean，把内核编译的临时文件都清除。</p>

<h4 id="c">第二步 保存所有C文件路径</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">cd linux-3.4.5
</span><span class="line">find ./ -name "*.c" | tee allsrc.txt
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-1">第三步 编译内核</h4>

<p>无需多讲，编译内核。</p>

<h4 id="strippy">第四步 用strip.py清除不参与编译的代码</h4>

<p>部分代码使用了include C代码，所以用<code>ignorefilelist</code>自定义文件过滤。<code>scripts</code>是工具目录，<code>./drivers/usb/gadget/</code>里inlucde C代码太多了，所以这两个目录直接目录过滤，添加到<code>ignorepathlist</code>自定义目录过滤里。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import sys
</span><span class="line">import os
</span><span class="line">
</span><span class="line">ignorefilelist=['fsr-2level.c','fsr-3level.c','percpu-km.c','percpu-vm.c','nf_conntrack_h323_types.c']
</span><span class="line">ignorepathlist=['./scripts/','./drivers/usb/gadget/']
</span><span class="line">
</span><span class="line">f = open('allsrc.txt','r')  
</span><span class="line">
</span><span class="line">for line in f.readlines():
</span><span class="line">	cfilename=line.strip('\n')
</span><span class="line">	objfilename=cfilename.replace(".c",".o")
</span><span class="line">	asmfilename=cfilename.replace(".c",".s")
</span><span class="line">	exefilename=cfilename.replace(".c","")
</span><span class="line">
</span><span class="line">	cfile=cfilename.split('/')[-1]
</span><span class="line">	#print cfile
</span><span class="line">	
</span><span class="line">	flag=False
</span><span class="line">	for item in ignorepathlist:
</span><span class="line">		if cfilename.find(item)!=-1:
</span><span class="line">			#print cfilename
</span><span class="line">			flag=True
</span><span class="line">			break
</span><span class="line">	if flag:
</span><span class="line">		continue
</span><span class="line">	
</span><span class="line">	if cfile in ignorefilelist:
</span><span class="line">		#print cfile,cfilename
</span><span class="line">		continue
</span><span class="line">	
</span><span class="line">	if  os.path.exists(objfilename):
</span><span class="line">		continue
</span><span class="line">	if os.path.exists(asmfilename):
</span><span class="line">		#print asmfilename
</span><span class="line">		continue
</span><span class="line">	if os.path.exists(exefilename):
</span><span class="line">		#print exefilename
</span><span class="line">		continue
</span><span class="line">	
</span><span class="line">	if os.path.exists(cfilename):
</span><span class="line">		print objfilename,"NOT USING and rm ",cfilename
</span><span class="line">		os.remove(cfilename)
</span><span class="line">		pass
</span><span class="line">
</span><span class="line">f.close()
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>保存代码为<code>strip.py</code>，保存在内核目录。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">cd linux-3.4.5
</span><span class="line">python strip.py
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-2">第五步 重新编译内核</h3>

<p>重新编译内核。</p>

<p>如果编译成功，清理临时文件后保存代码用于阅读；<br />
如果编译失败，恢复缺失的文件，修改strip.py，接着编译，直到内核重新编译通过，清理临时文件后保存代码用于阅读。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux内核代码预处理后便于阅读]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/19/preprocess-linux-kernel/"/>
    <updated>2016-07-19T13:39:01+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/19/preprocess-linux-kernel</id>
    <content type="html"><![CDATA[<p>linux 内核庞大而复杂。内核代码阅读的时候，有没有遇到因为宏定义或者inline层次太深而不知道到底代码是什么样子。代码预处理可以解决这个难题。</p>

<!--more-->

<p>平台：linux 3.4.5 ARM，PC linux上类似，更简单些。</p>

<h4 id="v1">加V=1重新编译内核</h4>

<p><code>make</code>内核增加<code>V=1</code>选项，会详细打印编译过程，<code>-B</code>是要求重新编译内核所有模块。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">cd linux-3.4.5 &amp;&amp; make ARCH=arm defconfig &amp;&amp; make ARCH=arm CROSS_COMPILE=arm-buildroot-linux-uclibcgnueabi- EXTRAVERSION=- -B V=1 uImage
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>编译内核并保存编译log到文件，搜索你要预编译的文件，如<code>mm/slab.c</code>，会找到如下编译命令：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">arm-buildroot-linux-uclibcgnueabi-gcc -Wp,-MD,mm/.slab.o.d  -nostdinc -isystem /home/test/build/gcc-4.9.8/build_arm/staging_dir/usr/bin/../lib/gcc/arm-buildroot-linux-uclibcgnueabi/4.9.8/include -I/home/test/linux/kernels/linux-3.4.5/arch/arm/include -Iarch/arm/include/generated -Iinclude  -include /home/test/linux/kernels/linux-3.4.5/include/linux/kconfig.h -D__KERNEL__ -mlittle-endian -Iarch/arm/mach-zx297510/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -O2 -marm -fno-dwarf2-cfi-asm -mabi=aapcs-linux -mno-thumb-interwork -funwind-tables -D__LINUX_ARM_ARCH__=7 -march=armv7-a -msoft-float -Uarm -Wframe-larger-than=1024 -fno-stack-protector -Wno-unused-but-set-variable -fomit-frame-pointer -g -fno-inline-functions-called-once -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack -DCC_HAVE_ASM_GOTO    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(slab)"  -D"KBUILD_MODNAME=KBUILD_STR(slab)" -c -o mm/.tmp_slab.o mm/slab.c
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section">编译预处理指定文件</h4>

<p>把编译命令修改成预处理命令：<code>-c -o mm/.tmp_slab.o</code>修改成<code>-E -o mm/slab.E mm/slab.c</code>，在内核目录<code>linux-3.4.5</code>直接执行。如果是交叉编译链，可能需要把<code>arm-buildroot-linux-uclibcgnueabi-gcc</code>所在路径加入到环境变量<code>PATH</code>里。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">arm-buildroot-linux-uclibcgnueabi-gcc -Wp,-MD,mm/.slab.o.d  -nostdinc -isystem /home/test/build/gcc-4.9.8/build_arm/staging_dir/usr/bin/../lib/gcc/arm-buildroot-linux-uclibcgnueabi/4.9.8/include -I/home/test/linux/kernels/linux-3.4.5/arch/arm/include -Iarch/arm/include/generated -Iinclude  -include /home/test/linux/kernels/linux-3.4.5/include/linux/kconfig.h -D__KERNEL__ -mlittle-endian -Iarch/arm/mach-zx297510/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -O2 -marm -fno-dwarf2-cfi-asm -mabi=aapcs-linux -mno-thumb-interwork -funwind-tables -D__LINUX_ARM_ARCH__=7 -march=armv7-a -msoft-float -Uarm -Wframe-larger-than=1024 -fno-stack-protector -Wno-unused-but-set-variable -fomit-frame-pointer -g -fno-inline-functions-called-once -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack -DCC_HAVE_ASM_GOTO    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(slab)"  -D"KBUILD_MODNAME=KBUILD_STR(slab)" -E -o mm/slab.E mm/slab.c
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>执行完命令，在内核的<code>mm</code>目录就能看到<code>slab.c</code>的预处理后文件<code>slab.E</code>文件了。看一下<code>kmalloc</code>函数代码，是不是清晰很多了。</p>

<p><code>slab_def.h</code>里的原始<code>kmalloc</code></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
</pre></td><td class="code"><pre><code class=""><span class="line">static __always_inline void *kmalloc(size_t size, gfp_t flags)
</span><span class="line">{
</span><span class="line">	struct kmem_cache *cachep;
</span><span class="line">	void *ret;
</span><span class="line">
</span><span class="line">	if (__builtin_constant_p(size)) {
</span><span class="line">		int i = 0;
</span><span class="line">
</span><span class="line">		if (!size)
</span><span class="line">			return ZERO_SIZE_PTR;
</span><span class="line">
</span><span class="line">#define CACHE(x) \
</span><span class="line">		if (size &lt;= x) \
</span><span class="line">			goto found; \
</span><span class="line">		else \
</span><span class="line">			i++;
</span><span class="line">#include &lt;linux/kmalloc_sizes.h&gt;
</span><span class="line">#undef CACHE
</span><span class="line">		return NULL;
</span><span class="line">found:
</span><span class="line">#ifdef CONFIG_ZONE_DMA
</span><span class="line">		if (flags &amp; GFP_DMA)
</span><span class="line">			cachep = malloc_sizes[i].cs_dmacachep;
</span><span class="line">		else
</span><span class="line">#endif
</span><span class="line">			cachep = malloc_sizes[i].cs_cachep;
</span><span class="line">
</span><span class="line">		ret = kmem_cache_alloc_trace(size, cachep, flags);
</span><span class="line">
</span><span class="line">		return ret;
</span><span class="line">	}
</span><span class="line">	return __kmalloc(size, flags);
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>预处理后的<code>kmalloc</code>,流程是不是清晰多了。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
</pre></td><td class="code"><pre><code class=""><span class="line">static inline __attribute__((always_inline)) __attribute__((always_inline)) void *kmalloc(size_t size, gfp_t flags)
</span><span class="line">{
</span><span class="line"> struct kmem_cache *cachep;
</span><span class="line"> void *ret;
</span><span class="line">
</span><span class="line"> if (__builtin_constant_p(size)) {
</span><span class="line">  int i = 0;
</span><span class="line">
</span><span class="line">  if (!size)
</span><span class="line">   return ((void *)16);
</span><span class="line">
</span><span class="line"># 1 "include/linux/kmalloc_sizes.h" 1
</span><span class="line">
</span><span class="line"> if (size &lt;= 32) goto found; else i++;
</span><span class="line"> if (size &lt;= 64) goto found; else i++;
</span><span class="line"> if (size &lt;= 128) goto found; else i++;
</span><span class="line"> if (size &lt;= 192) goto found; else i++;
</span><span class="line"> if (size &lt;= 256) goto found; else i++;
</span><span class="line"> if (size &lt;= 512) goto found; else i++;
</span><span class="line"> if (size &lt;= 1024) goto found; else i++;
</span><span class="line"> if (size &lt;= 2048) goto found; else i++;
</span><span class="line"> if (size &lt;= 4096) goto found; else i++;
</span><span class="line"> if (size &lt;= 8192) goto found; else i++;
</span><span class="line"> if (size &lt;= 16384) goto found; else i++;
</span><span class="line"> if (size &lt;= 32768) goto found; else i++;
</span><span class="line"> if (size &lt;= 65536) goto found; else i++;
</span><span class="line"> if (size &lt;= 131072) goto found; else i++;
</span><span class="line"> if (size &lt;= 262144) goto found; else i++;
</span><span class="line"> if (size &lt;= 524288) goto found; else i++;
</span><span class="line"> if (size &lt;= 1048576) goto found; else i++;
</span><span class="line"> if (size &lt;= 2097152) goto found; else i++;
</span><span class="line"> if (size &lt;= 4194304) goto found; else i++;
</span><span class="line"># 145 "include/linux/slab_def.h" 2
</span><span class="line">
</span><span class="line">  return ((void *)0);
</span><span class="line">found:
</span><span class="line">   cachep = malloc_sizes[i].cs_cachep;
</span><span class="line">
</span><span class="line">  ret = kmem_cache_alloc_trace(size, cachep, flags);
</span><span class="line">
</span><span class="line">  return ret;
</span><span class="line"> }
</span><span class="line"> return __kmalloc(size, flags);
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux栈和内存管理]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/18/linux-stack-and-memory-management/"/>
    <updated>2016-07-18T09:11:52+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/18/linux-stack-and-memory-management</id>
    <content type="html"><![CDATA[<p>先记录，待细看</p>

<!--more-->

<p><a href="http://blog.csdn.net/daniel_ice/article/details/8146003">http://blog.csdn.net/daniel_ice/article/details/8146003</a></p>

<p><a href="http://gityuan.com/2015/10/30/kernel-memory/">http://gityuan.com/2015/10/30/kernel-memory/</a></p>

<p><a href="http://www.2ndmoon.net/weblog/?p=509">http://www.2ndmoon.net/weblog/?p=509</a></p>

<p><a href="http://www.cnblogs.com/tolimit/p/4610974.html">http://www.cnblogs.com/tolimit/p/4610974.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pthread退出时自动回收资源]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/18/pthread-autoclean-when-exiting/"/>
    <updated>2016-07-18T08:49:16+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/18/pthread-autoclean-when-exiting</id>
    <content type="html"><![CDATA[<p>pthread线程创建后默认属性是joinable，线程函数执行完资源不会自动回收线程资源，需要主进程<code>pthread_join</code>进行回收，否则就会造成不必要的内存占用，频繁创建退出线程可能会造成系统内存耗尽。除了<code>pthread_join</code>用这种办法更好些。</p>

<!--more-->

<p>线程函数加上<code>pthread_detach(pthread_self())</code>的话，线程状态改变成<code>unjoinable</code>，这样线程函数尾部直接 pthread_exit线程就会自动退出。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">static void  thread_fn( void *args)
</span><span class="line">{
</span><span class="line">	pthread_detach(pthread_self());
</span><span class="line">
</span><span class="line">	while(flag)
</span><span class="line">	{
</span><span class="line">		/*do something*/
</span><span class="line">	}
</span><span class="line">
</span><span class="line">	pthread_exit(NULL);
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section">参考文章</h2>

<p><a href="http://blog.csdn.net/trinea/article/details/5191165">http://blog.csdn.net/trinea/article/details/5191165</a></p>

<p><a href="http://www.lxway.net/499814656.html">http://www.lxway.net/499814656.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux内核kmalloc和vmalloc的区别]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/18/kmalloc-vs-vmalloc/"/>
    <updated>2016-07-18T08:41:56+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/18/kmalloc-vs-vmalloc</id>
    <content type="html"><![CDATA[<p>kmalloc 和 vmalloc的区别</p>

<!--more-->

<h4 id="kmalloc">kmalloc</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">void *kmalloc(size_t size, gfp_t flags)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>kmalloc是内核中最常用的一种内存分配方式，<strong>连续的物理内存</strong>。如果size是常量，调用<code>kmem_cache_alloc_trace</code>分配，否则调用<code>__kmalloc</code>分配。size如果是常量且大于4M，直接返回0（内核版本3.4.5）；如果size是0，返回地址是<code>((void *)16)</code>。</p>

<h4 id="vmalloc">vmalloc</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">void *vmalloc(unsigned long size)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>kmalloc内存分配方式都是物理连续的，能保证较低的平均访问时间。但是在某些场合中，对内存区的请求不是很频繁，较高的内存访问时间也 可以接受，这是就可以分配一段<strong>线性连续，物理不连续</strong>的地址，带来的好处是一次可以分配较大块的内存。vmalloc对 一次能分配的内存大小没有明确限制。</p>

<h5 id="kmalloc-1">kmalloc预处理后的代码</h5>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
</pre></td><td class="code"><pre><code class=""><span class="line">static inline __attribute__((always_inline)) __attribute__((always_inline)) void *kmalloc(size_t size, gfp_t flags)
</span><span class="line">{
</span><span class="line"> struct kmem_cache *cachep;
</span><span class="line"> void *ret;
</span><span class="line">
</span><span class="line"> if (__builtin_constant_p(size)) {
</span><span class="line">  int i = 0;
</span><span class="line">
</span><span class="line">  if (!size)
</span><span class="line">   return ((void *)16);
</span><span class="line">
</span><span class="line"># 1 "include/linux/kmalloc_sizes.h" 1
</span><span class="line"> if (size &lt;= 32) goto found; else i++;
</span><span class="line"> if (size &lt;= 64) goto found; else i++;
</span><span class="line"> if (size &lt;= 128) goto found; else i++;
</span><span class="line"> if (size &lt;= 192) goto found; else i++;
</span><span class="line"> if (size &lt;= 256) goto found; else i++;
</span><span class="line"> if (size &lt;= 512) goto found; else i++;
</span><span class="line"> if (size &lt;= 1024) goto found; else i++;
</span><span class="line"> if (size &lt;= 2048) goto found; else i++;
</span><span class="line"> if (size &lt;= 4096) goto found; else i++;
</span><span class="line"> if (size &lt;= 8192) goto found; else i++;
</span><span class="line"> if (size &lt;= 16384) goto found; else i++;
</span><span class="line"> if (size &lt;= 32768) goto found; else i++;
</span><span class="line"> if (size &lt;= 65536) goto found; else i++;
</span><span class="line"> if (size &lt;= 131072) goto found; else i++;
</span><span class="line"> if (size &lt;= 262144) goto found; else i++;
</span><span class="line"> if (size &lt;= 524288) goto found; else i++;
</span><span class="line"> if (size &lt;= 1048576) goto found; else i++;
</span><span class="line"> if (size &lt;= 2097152) goto found; else i++;
</span><span class="line"> if (size &lt;= 4194304) goto found; else i++;
</span><span class="line"># 145 "include/linux/slab_def.h" 2
</span><span class="line">
</span><span class="line">  return ((void *)0);
</span><span class="line">found:
</span><span class="line">   cachep = malloc_sizes[i].cs_cachep;
</span><span class="line">
</span><span class="line">  ret = kmem_cache_alloc_trace(size, cachep, flags);
</span><span class="line">
</span><span class="line">  return ret;
</span><span class="line"> }
</span><span class="line"> return __kmalloc(size, flags);
</span><span class="line">}
</span><span class="line">
</span><span class="line">void *__kmalloc(size_t size, gfp_t flags)
</span><span class="line">{
</span><span class="line"> return __do_kmalloc(size, flags, ((void *)0));
</span><span class="line">}
</span><span class="line">
</span><span class="line">static inline __attribute__((always_inline)) __attribute__((always_inline)) void *__do_kmalloc(size_t size, gfp_t flags, void *caller)
</span><span class="line">{
</span><span class="line"> struct kmem_cache *cachep;
</span><span class="line"> void *ret;
</span><span class="line"> 
</span><span class="line"> cachep = __find_general_cachep(size, flags);
</span><span class="line"> if (__builtin_expect(!!(((unsigned long)(cachep) &lt;= (unsigned long)((void *)16))), 0))
</span><span class="line">  return cachep;
</span><span class="line"> ret = __cache_alloc(cachep, flags, caller);
</span><span class="line">
</span><span class="line"> trace_kmalloc((unsigned long) caller, ret,
</span><span class="line">        size, cachep-&gt;buffer_size, flags);
</span><span class="line">
</span><span class="line"> return ret;
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h1 id="section">引用文章</h1>

<p><a href="http://www.ahlinux.com/start/kernel/18604.html">http://www.ahlinux.com/start/kernel/18604.html</a></p>

<p><a href="http://blog.csdn.net/bullbat/article/details/7181396">http://blog.csdn.net/bullbat/article/details/7181396</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux kernel全局变量contig_page_data含义]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/13/kernel-contig_page_data/"/>
    <updated>2016-07-13T09:03:20+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/13/kernel-contig_page_data</id>
    <content type="html"><![CDATA[<p><code>contig_page_data</code>是内核内存管理一个很重要的变量。</p>

<!--more-->

<p>平台：uClinux 内核版本号：linux-3.4.12</p>

<p><img src="http://7bv9id.com1.z0.glb.clouddn.com/contig_page_data.png" alt="enter image description here" /></p>

<p><code>watermark</code>是3840 4800 5760对应 watermark[min] watermark[low] watermark[high]，这里是page数，一个page 4K，所以<code>watermark</code>对应<code>min_free_kbytes</code>是3840*4K是15360（15M），符合配置<code>echo 15360 &gt; /proc/sys/vm/min_free_kbytes</code>。其他计算如下。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line"> watermark[min] = min_free_kbytes换算为page单位即可
</span><span class="line"> watermark[low] = watermark[min] * 5 / 4
</span><span class="line"> watermark[high] = watermark[min] * 3 / 2
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在系统空闲内存低于 watermark[low]时，开始启动内核线程kswapd进行内存回收，直到该zone的空闲内存数量达到watermark[high]后停止回收。如果上层申请内存的速度太快，导致空闲内存降至watermark[min]后，内核就会进行direct reclaim（直接回收），即直接在应用程序的进程上下文中进行回收，再用回收上来的空闲页满足内存申请，因此实际会阻塞应用程序，带来一定的响应延迟，而且可能会触发系统OOM。这是因为watermark[min]以下的内存属于系统的自留内存，用以满足特殊使用，所以不会给用户态的普通申请来用。</p>

<p>free_area里order是0到10，对应4K到4M。free_list[n]是双向链表，只有next的next指向同样的节点才是表示链表为空。（双向链表，很明显如果只有两个节点，next和prev都是另一个节点）。和<code>cat /proc/pagetypeinfo</code>信息一致。</p>

<p><code>contig_page_data</code>里的<code>vm_stat</code>对应mmzone.h里<code>zone_stat_item</code>枚举。另外本身有一个内核全局变量<code>vm_stat</code>，值和<code>contig_page_data</code>的这个<code>vm_stat</code>一样的。这个参数可以对照着<code>/proc/meminfo</code>一起看。</p>

<p>page_alloc.c  show_free_areas()</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">for (type = 0; type &lt; MIGRATE_TYPES; type++) {
</span><span class="line">				if (!list_empty(&amp;area-&gt;free_list[type]))
</span><span class="line">					types[order] |= 1 &lt;&lt; type;
</span><span class="line">			}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>mmzone.h里看出MIGRATE_TYPES为4。<strong>0是UNMOVABLE区，1是RECLAIMABLE可回收区，2是可MOVABLE区，3是PCPTYPES或者RESERVE保留区</strong>。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
</pre></td><td class="code"><pre><code class=""><span class="line">enum {
</span><span class="line">	MIGRATE_UNMOVABLE,
</span><span class="line">	MIGRATE_RECLAIMABLE,
</span><span class="line">	MIGRATE_MOVABLE,
</span><span class="line">	MIGRATE_PCPTYPES,	/* the number of types on the pcp lists */
</span><span class="line">	MIGRATE_RESERVE = MIGRATE_PCPTYPES,
</span><span class="line">#ifdef CONFIG_CMA
</span><span class="line">	/*
</span><span class="line">	 * MIGRATE_CMA migration type is designed to mimic the way
</span><span class="line">	 * ZONE_MOVABLE works.  Only movable pages can be allocated
</span><span class="line">	 * from MIGRATE_CMA pageblocks and page allocator never
</span><span class="line">	 * implicitly change migration type of MIGRATE_CMA pageblock.
</span><span class="line">	 *
</span><span class="line">	 * The way to use it is to change migratetype of a range of
</span><span class="line">	 * pageblocks to MIGRATE_CMA which can be done by
</span><span class="line">	 * __free_pageblock_cma() function.  What is important though
</span><span class="line">	 * is that a range of pageblocks must be aligned to
</span><span class="line">	 * MAX_ORDER_NR_PAGES should biggest page be bigger then
</span><span class="line">	 * a single pageblock.
</span><span class="line">	 */
</span><span class="line">	MIGRATE_CMA,
</span><span class="line">#endif
</span><span class="line">#ifdef CONFIG_MEMORY_ISOLATION
</span><span class="line">	MIGRATE_ISOLATE,	/* can't allocate from here */
</span><span class="line">#endif
</span><span class="line">	MIGRATE_TYPES
</span><span class="line">};
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
</pre></td><td class="code"><pre><code class=""><span class="line">enum zone_stat_item {
</span><span class="line">	/* First 128 byte cacheline (assuming 64 bit words) */
</span><span class="line">	NR_FREE_PAGES,
</span><span class="line">	NR_ALLOC_BATCH,
</span><span class="line">	NR_LRU_BASE,
</span><span class="line">	NR_INACTIVE_ANON = NR_LRU_BASE, /* must match order of LRU_[IN]ACTIVE */
</span><span class="line">	NR_ACTIVE_ANON,		/*  "     "     "   "       "         */
</span><span class="line">	NR_INACTIVE_FILE,	/*  "     "     "   "       "         */
</span><span class="line">	NR_ACTIVE_FILE,		/*  "     "     "   "       "         */
</span><span class="line">	NR_UNEVICTABLE,		/*  "     "     "   "       "         */
</span><span class="line">	NR_MLOCK,		/* mlock()ed pages found and moved off LRU */
</span><span class="line">	NR_ANON_PAGES,	/* Mapped anonymous pages */
</span><span class="line">	NR_FILE_MAPPED,	/* pagecache pages mapped into pagetables.
</span><span class="line">			   only modified from process context */
</span><span class="line">	NR_FILE_PAGES,
</span><span class="line">	NR_FILE_DIRTY,
</span><span class="line">	NR_WRITEBACK,
</span><span class="line">	NR_SLAB_RECLAIMABLE,
</span><span class="line">	NR_SLAB_UNRECLAIMABLE,
</span><span class="line">	NR_PAGETABLE,		/* used for pagetables */
</span><span class="line">	NR_KERNEL_STACK,
</span><span class="line">	/* Second 128 byte cacheline */
</span><span class="line">	NR_UNSTABLE_NFS,	/* NFS unstable pages */
</span><span class="line">	NR_BOUNCE,
</span><span class="line">	NR_VMSCAN_WRITE,
</span><span class="line">	NR_VMSCAN_IMMEDIATE,	/* Prioritise for reclaim when writeback ends */
</span><span class="line">	NR_WRITEBACK_TEMP,	/* Writeback using temporary buffers */
</span><span class="line">	NR_ISOLATED_ANON,	/* Temporary isolated pages from anon lru */
</span><span class="line">	NR_ISOLATED_FILE,	/* Temporary isolated pages from file lru */
</span><span class="line">	NR_SHMEM,		/* shmem pages (included tmpfs/GEM pages) */
</span><span class="line">	NR_DIRTIED,		/* page dirtyings since bootup */
</span><span class="line">	NR_WRITTEN,		/* page writings since bootup */
</span><span class="line">#ifdef CONFIG_NUMA
</span><span class="line">	NUMA_HIT,		/* allocated in intended node */
</span><span class="line">	NUMA_MISS,		/* allocated in non intended node */
</span><span class="line">	NUMA_FOREIGN,		/* was intended here, hit elsewhere */
</span><span class="line">	NUMA_INTERLEAVE_HIT,	/* interleaver preferred this zone */
</span><span class="line">	NUMA_LOCAL,		/* allocation from local node */
</span><span class="line">	NUMA_OTHER,		/* allocation from other node */
</span><span class="line">#endif
</span><span class="line">	NR_ANON_TRANSPARENT_HUGEPAGES,
</span><span class="line">	NR_FREE_CMA_PAGES,
</span><span class="line">	NR_VM_ZONE_STAT_ITEMS };
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section">参考文章</h4>

<p><a href="http://kernel.taobao.org/index.php?title=Kernel_Documents/mm_sysctl">http://kernel.taobao.org/index.php?title=Kernel_Documents/mm_sysctl</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux应用内存占用maps分析]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/12/app-mem-used-on-linux/"/>
    <updated>2016-07-12T10:50:20+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/12/app-mem-used-on-linux</id>
    <content type="html"><![CDATA[<p>假设一个应用的pid是PID，则<code>cat /proc/PID/maps</code>显示这个应用的内存占用。</p>

<!--more-->

<h3 id="maps">maps格式</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">address           perms offset  dev   inode   pathname
</span><span class="line">00008000-00009000 r-xp 00000000 b3:02 317712     /home/pi/test/pmap/a.out
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ol>
  <li><strong>address</strong> - This is the starting and ending address of the region in the process’s address space。说明：都是虚拟地址，并不代码真实的物理地址。</li>
  <li><strong>permissions</strong> - This describes how pages in the region can be accessed. There are four different permissions: read, write, execute, and shared. If read/write/execute are disabled, a ‘-‘ will appear instead of the ‘r’/’w’/’x’. If a region is not shared, it is private, so a ‘p’ will appear instead of an ‘s’. If the process attempts to access memory in a way that is not permitted, a segmentation fault is generated. Permissions can be changed using the <code>mprotect</code> system call.</li>
  <li><strong>offset</strong> - If the region was mapped from a file (using mmap), this is the offset in the file where the mapping begins. If the memory was not mapped from a file, it’s just 0.</li>
  <li><strong>device</strong> - If the region was mapped from a file, this is the major and minor device number (in hex) where the file lives.</li>
  <li><strong>inode</strong> - If the region was mapped from a file, this is the file number.</li>
  <li><strong>pathname</strong> - If the region was mapped from a file, this is the name of the file. This field is blank for anonymous mapped regions. There are also special regions with names like [heap], [stack], or [vdso]. [vdso] stands for virtual dynamic shared object. It’s used by system calls to switch to kernel mode. Here’s a good article about it.</li>
</ol>

<h3 id="section">实例分析</h3>

<p>写一个简单的实例main.c，funcA地址在代码段，s_buf在数据段，buf是局部变量，在栈空间，pheap是malloc申请的，是heap空间。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
</pre></td><td class="code"><pre><code class=""><span class="line">#include &lt;stdio.h&gt;
</span><span class="line">#include &lt;stdlib.h&gt;
</span><span class="line">#include &lt;unistd.h&gt;
</span><span class="line">
</span><span class="line">static char s_buf[1024];
</span><span class="line">void funcA(void)
</span><span class="line">{
</span><span class="line">  printf("funcA address:%08x\n",funcA);
</span><span class="line">}
</span><span class="line">
</span><span class="line">int main(int argc,char *argv[])
</span><span class="line">{
</span><span class="line">  int i = 0;
</span><span class="line">  char buf[1024] = {0};
</span><span class="line">  char *pheap = malloc(2048);
</span><span class="line">
</span><span class="line">  for(i=0;i&lt;1000;i++)
</span><span class="line">  {
</span><span class="line">    funcA();
</span><span class="line">    printf("buf address:%08x\n",buf);
</span><span class="line">    printf("s_buf address:%08x\n",s_buf);
</span><span class="line">    printf("pheap address:%08x\n",pheap);
</span><span class="line">    sleep(10);
</span><span class="line">  }
</span><span class="line">  free(pheap);
</span><span class="line">  return 0;
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>编译运行</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$gcc main.c
</span><span class="line">$./a.out
</span><span class="line">funcA address:000084a0
</span><span class="line">buf address:becb9318
</span><span class="line">s_buf address:000107ac
</span><span class="line">pheap address:01171008
</span><span class="line">funcA address:000084a0
</span><span class="line">buf address:becb9318
</span><span class="line">s_buf address:000107ac
</span><span class="line">pheap address:01171008
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在另一个窗口</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ ps aux | grep out
</span><span class="line">pi       27725  0.0  0.2   1676   424 pts/0    S+   10:43   0:00 ./a.out
</span><span class="line">$ cat /proc/27725/maps &gt; a.out.maps
</span><span class="line">$ cat a.out.maps
</span><span class="line">00008000-00009000 r-xp 00000000 b3:02 317712     /home/pi/test/pmap/a.out
</span><span class="line">00010000-00011000 rw-p 00000000 b3:02 317712     /home/pi/test/pmap/a.out
</span><span class="line">01171000-01192000 rw-p 00000000 00:00 0          [heap]
</span><span class="line">b6e36000-b6f59000 r-xp 00000000 b3:02 1925       /lib/arm-linux-gnueabihf/libc-2.13.so
</span><span class="line">b6f59000-b6f60000 ---p 00123000 b3:02 1925       /lib/arm-linux-gnueabihf/libc-2.13.so
</span><span class="line">b6f60000-b6f62000 r--p 00122000 b3:02 1925       /lib/arm-linux-gnueabihf/libc-2.13.so
</span><span class="line">b6f62000-b6f63000 rw-p 00124000 b3:02 1925       /lib/arm-linux-gnueabihf/libc-2.13.so
</span><span class="line">b6f63000-b6f66000 rw-p 00000000 00:00 0
</span><span class="line">b6f74000-b6f76000 r-xp 00000000 b3:02 27194      /usr/lib/arm-linux-gnueabihf/libcofi_rpi.so
</span><span class="line">b6f76000-b6f7d000 ---p 00002000 b3:02 27194      /usr/lib/arm-linux-gnueabihf/libcofi_rpi.so
</span><span class="line">b6f7d000-b6f7e000 rw-p 00001000 b3:02 27194      /usr/lib/arm-linux-gnueabihf/libcofi_rpi.so
</span><span class="line">b6f7e000-b6f9b000 r-xp 00000000 b3:02 1919       /lib/arm-linux-gnueabihf/ld-2.13.so
</span><span class="line">b6f9e000-b6fa2000 rw-p 00000000 00:00 0
</span><span class="line">b6fa2000-b6fa3000 r-xp 00000000 00:00 0          [sigpage]
</span><span class="line">b6fa3000-b6fa4000 r--p 0001d000 b3:02 1919       /lib/arm-linux-gnueabihf/ld-2.13.so
</span><span class="line">b6fa4000-b6fa5000 rw-p 0001e000 b3:02 1919       /lib/arm-linux-gnueabihf/ld-2.13.so
</span><span class="line">bec99000-becba000 rw-p 00000000 00:00 0          [stack]
</span><span class="line">ffff0000-ffff1000 r-xp 00000000 00:00 0          [vectors]
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>a.out.maps内容分析如下</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">00008000-00009000 r-xp 00000000 b3:02 317712     /home/pi/test/pmap/a.out  
</span><span class="line">代码段，funcA在这个区间,权限是r-xp，有读、执行权限，p是private
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">00010000-00011000 rw-p 00000000 b3:02 317712     /home/pi/test/pmap/a.out  
</span><span class="line">数据段，s_buf在这个区间,权限是rw-p，有读写，p是private
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">01171000-01192000 rw-p 00000000 00:00 0          [heap]
</span><span class="line">堆空间，pheap在这个区间，权限是rw-p，有读写，p是private
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">b6e36000-b6f59000 r-xp 00000000 b3:02 1925       /lib/arm-linux-gnueabihf/libc-2.13.so
</span><span class="line">libc库代码段
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">b6f59000-b6f60000 ---p 00123000 b3:02 1925       /lib/arm-linux-gnueabihf/libc-2.13.so
</span><span class="line">libc库内存防止越界空间，权限是---p，没有rwx权限，用户访问就触发段错误
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">b6f60000-b6f62000 r--p 00122000 b3:02 1925       /lib/arm-linux-gnueabihf/libc-2.13.so
</span><span class="line">libc库只读内存区。如果const变量，则在代码段；如果是全局变量则在数据段，还不知道这个区域内容。
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">b6f62000-b6f63000 rw-p 00124000 b3:02 1925       /lib/arm-linux-gnueabihf/libc-2.13.so
</span><span class="line">libc库数据段
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">b6f63000-b6f66000 rw-p 00000000 00:00 0
</span><span class="line">b6f9e000-b6fa2000 rw-p 00000000 00:00 0
</span><span class="line">未知，权限rw-p应该共享库相关的数据区
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">b6f74000-b6f76000 r-xp 00000000 b3:02 27194      /usr/lib/arm-linux-gnueabihf/libcofi_rpi.so
</span><span class="line">b6f76000-b6f7d000 ---p 00002000 b3:02 27194      /usr/lib/arm-linux-gnueabihf/libcofi_rpi.so
</span><span class="line">b6f7d000-b6f7e000 rw-p 00001000 b3:02 27194      /usr/lib/arm-linux-gnueabihf/libcofi_rpi.so
</span><span class="line">b6f7e000-b6f9b000 r-xp 00000000 b3:02 1919       /lib/arm-linux-gnueabihf/ld-2.13.so
</span><span class="line">b6fa3000-b6fa4000 r--p 0001d000 b3:02 1919       /lib/arm-linux-gnueabihf/ld-2.13.so
</span><span class="line">b6fa4000-b6fa5000 rw-p 0001e000 b3:02 1919       /lib/arm-linux-gnueabihf/ld-2.13.so
</span><span class="line">同libc分析
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">b6fa2000-b6fa3000 r-xp 00000000 00:00 0          [sigpage]
</span><span class="line">和信号相关的一个page，ARM架构独有好像
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">bec99000-becba000 rw-p 00000000 00:00 0          [stack]
</span><span class="line">栈空间，局部变量buf在这个区间
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">ffff0000-ffff1000 r-xp 00000000 00:00 0          [vectors]
</span><span class="line">中断向量
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>待完善…</p>

<h3 id="section-1">参考资料</h3>

<p><a href="http://stackoverflow.com/questions/1401359/understanding-linux-proc-id-maps">http://stackoverflow.com/questions/1401359/understanding-linux-proc-id-maps</a></p>

<p><a href="http://stackoverflow.com/questions/16524895/proc-pid-maps-shows-pages-with-no-rwx-permissions-on-x86-64-linux">http://stackoverflow.com/questions/16524895/proc-pid-maps-shows-pages-with-no-rwx-permissions-on-x86-64-linux</a></p>

<p><a href="https://yq.aliyun.com/articles/54405">https://yq.aliyun.com/articles/54405</a></p>
]]></content>
  </entry>
  
</feed>
