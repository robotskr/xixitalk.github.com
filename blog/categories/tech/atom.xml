<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tech | xixitalk's snippet]]></title>
  <link href="http://xixitalk.github.io/blog/categories/tech/atom.xml" rel="self"/>
  <link href="http://xixitalk.github.io/"/>
  <updated>2016-10-14T00:52:43+00:00</updated>
  <id>http://xixitalk.github.io/</id>
  <author>
    <name><![CDATA[xixitalk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[stunnel双向证书验证]]></title>
    <link href="http://xixitalk.github.io/blog/2016/10/13/Stunnel-With-Bilateral-Authentication/"/>
    <updated>2016-10-13T20:09:49+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/10/13/Stunnel-With-Bilateral-Authentication</id>
    <content type="html"><![CDATA[<p>stunnel 双向证书验证，防止有人偷偷连接stunnel服务器。</p>

<!--more-->

<h2 id="section">第一步 生成证书</h2>

<p>生成两个证书，一个服务端的<code>stunnel_s.pem</code>，一个客户端的<code>stunnel_c.pem</code>，有效期设置长一点1000天。</p>

<p><code>
$openssl req -new -x509 -days 10000 -nodes -out stunnel_c.pem -keyout stunnel_c.pem
$openssl req -new -x509 -days 10000 -nodes -out stunnel_s.pem -keyout stunnel_s.pem
</code></p>

<h2 id="stunnelconf">第二步 服务器端stunnel.conf</h2>

<p>将证书拷贝到/etc/stunnel目录，设置权限400.</p>

<p><code>
$sudo cp stunnel_s.pem /etc/stunnel/
$sudo cp stunnel_c.pem /etc/stunnel/
$sudo chmod 400 /etc/stunnel/*.pem
</code></p>

<p>创建<code>stunnel.conf</code>文件，内容如下，拷贝到<code>/etc/stunnel/</code>目录。对外端口是8445，加密的是<a href="https://github.com/cyfdecyf/cow">cow</a>的7777端口,根据情况自行修改。</p>

<p>```
;fips=no
client = no
sslVersion=all</p>

<p>chroot = /var/lib/stunnel4/
setuid = root
setgid = root</p>

<p>pid = /stunnel4.open.pid
;output = /stunnel.open.log
cert = /etc/stunnel/stunnel_s.pem
key = /etc/stunnel/stunnel_s.pem</p>

<p>[open]
accept = 8445
connect = 7777</p>

<p>verify=2
CAfile = /etc/stunnel/stunnel_c.pem
```</p>

<p>服务器端重启</p>

<p><code>
$sudo service  stunnel4  restart
</code></p>

<h2 id="stunnelconf-1">第三步 客户端stunnel.conf</h2>

<p>我的客户端运行在windows系统，所以下面的配置是windows上stunnel验证的。其他系统自行验证。</p>

<p>将<code>stunnel_c.pem</code>和<code>stunnel_s.pem</code>（删除证书里BEGIN PRIVATE KEY私钥部分，只保留BEGIN CERTIFICATE公钥部分）拷贝到<code>stunnel</code>安装目录，修改<code>stunnel.conf</code>文件，配置如下。<code>stunnel_ip</code>是服务器端stunnel的IP，端口是8084，浏览器配置127.0.0.1:8084 HTTP代理，其他端口自行修改。</p>

<p>```
fips=no
client = yes
sslVersion = all
socket = l:TCP_NODELAY=1
socket = r:TCP_NODELAY=1
socket = l:SO_LINGER=1:1
socket = r:SO_LINGER=1:1</p>

<p>[fastssl]
accept = 127.0.0.1:8084
connect = stunnel_ip:8445</p>

<p>verify = 2
CAfile = stunnel_s.pem</p>

<p>cert = stunnel_c.pem
key = stunnel_c.pem
```</p>

<p>如果客户端连接<code>stunnel</code>服务器端需要HTTP代理（公司网络），<code>fastssl</code>部分这样配置</p>

<p><code>
[fastssl]
accept = 127.0.0.1:8084
connect = proxy.company.com:80
protocol = connect
protocolHost = stunnel_ip:8445
</code></p>

<h2 id="stunnel">stunnel安全说明</h2>

<p>发现stunnel当服务器配置<code>verify = 2</code>时，服务器端会检查客户端证书是否在<code>CAfile</code>中。但是客户端配置<code>verify = 0</code>，客户端并不检查服务器端的证书，就算<code>CAfile</code>配置错误的服务器证书还是可以正常连接。</p>

<p>所以，stunnel服务端的<strong>防盗</strong>连安全机制是：在服务器<code>CAfile</code>里配置客户端的证书，并设置<code>verify = 2</code>，服务器端检查客户端证书不在<code>CAfile</code>列表则断开连接。</p>

<p>同样，为了避免客户端连接到<strong>假的服务端</strong>，则需要配置<code>verify = 2</code>，并把服务端的<strong>公钥证书</strong>放在<code>CAfile</code>里。</p>

<p>综上所述，当服务端和客户端都配置<code>verify = 2</code>，才是<strong>双向证书验证</strong>。</p>

<h2 id="pem">pem证书说明</h2>

<p>pem证书是文本文件，里面<code>BEGIN PRIVATE KEY</code>和<code>END PRIVATE KEY</code>是私钥部分，<code>BEGIN CERTIFICATE</code>和<code>END CERTIFICATE</code>是公钥部分。<code>cert</code>和<code>key</code>配置完整的pem，而<code>CAfile</code>里只包含对方的公钥部分即可，即服务端<code>CAfile</code>是客户端的公钥，客户端<code>CAfile</code>是服务端的公钥。遵循这样原则，客户端的私钥只放客户端，服务端的私钥只放服务端，而公钥是可以多处存放的。</p>

<p><code>
-----BEGIN PRIVATE KEY-----
MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQCo9WC13gg9WCRX
...
kPpWg2PAANRi5Bmr9ScvBISSYQ==
-----END PRIVATE KEY-----
-----BEGIN CERTIFICATE-----
MIID6TCCAtGgAwIBAgIJANBMqvP0YuV4MA0GCSqGSIb3DQEBBQUAMIGKMQswCQYD
...
o5tKoL9GcMhyjDoD9GCMfP6fY5DwPqhhqFTsPd47DzEdQ8amxPMn5kR/w/xk
-----END CERTIFICATE-----
</code></p>

<h2 id="section-1">参考博客</h2>

<ol>
  <li><a href="http://www.hawu.me/operation/886">squid + stunnel » 跨越长城，科学上网！</a></li>
  <li><a href="http://briteming.blogspot.com/2013/03/stunnel.html">Using stunnel With Bilateral Authentication</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DNS协议学习笔记之DNS查询]]></title>
    <link href="http://xixitalk.github.io/blog/2016/10/10/dns-protocol/"/>
    <updated>2016-10-10T19:00:54+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/10/10/dns-protocol</id>
    <content type="html"><![CDATA[<p>DNS学习概要：  </p>

<ol>
  <li>DNS几个概念：A记录、AAAA记录、MX记录、CNAME记录、TEXT记录、URL转发、NS记录</li>
  <li>DNS查询报文</li>
  <li>DNS响应报文</li>
  <li>Google DNS over HTTPS</li>
</ol>

<!--more-->

<h2 id="dns">1.  DNS几个概念</h2>

<p>DNS几个概念，参看这两篇文章：</p>

<p><a href="https://www.ezloo.com/2011/04/a_mx_cname_txt_aaaa_ns.html">常用域名记录解释：A记录、MX记录、CNAME记录、TXT记录、AAAA记录、NS记录</a></p>

<p><a href="http://ju.outofmemory.cn/entry/187521">域名DNS解析相关概念 — A记录，MX记录，CNAME记录，url转发，ns记录</a></p>

<h2 id="dns-1">2. DNS查询报文</h2>

<h3 id="section">2.1 整体结构</h3>

<p><code>
    +---------------------+
    |        Header       |
    +---------------------+
    |       Question      | the question for the name server
    +---------------------+
    |        Answer       | RRs answering the question
    +---------------------+
    |      Authority      | RRs pointing toward an authority
    +---------------------+
    |      Additional     | RRs holding additional information
    +---------------------+
</code></p>

<p><img src="http://s6.51cto.com/wyfs02/M02/4D/A8/wKiom1RW2KaCvqHrAABEwMOH0AE633.jpg" alt="DNSrequest" /></p>

<h3 id="section-1">2.2 报文头</h3>

<p><img src="http://xixitalkgithubio.qiniudn.com/dnsheader.jpg" alt="DNSrequest2" /></p>

<table border="1">
  <tbody>
    <tr>
      <td>16位标识</td>
      <td>16位标志</td>
    </tr>
    <tr>
      <td>16位问题数</td>
      <td>16资源记录数</td>
    </tr>
    <tr>
      <td>16位授权资源记录数</td>
      <td>16位额外资源记录数</td>
    </tr>
  </tbody>
</table>

<p>整个DNS包头12个字节。  </p>

<p><strong>16位标志详解</strong></p>

<table border="1">
  <tbody>
    <tr>
      <td>1位QR</td>
      <td>4位Opcode</td>
      <td>1位AA</td>
      <td>1位TC</td>
      <td>1位RD</td>
      <td>1位RA</td>
      <td>3位清0</td>
      <td>4位RCode</td>
    </tr>
  </tbody>
</table>

<p>QR：0表示查询报文，1表示响应报文<br />
Opcode：通常值为0(标准查询)，其他值为1(反向查询)和2(服务器状态请求)。<br />
AA：表示授权回答(authoritative answer).<br />
TC：表示可截断的(truncated)<br />
RD：表示期望递归<br />
RA：表示可用递归，随后3bit必须为0<br />
RCode：返回码，通常为0(没有差错)和3(出错，该域名不存在)  </p>

<h3 id="question">2.3 查询问题(Question)结构</h3>

<p>```</p>

<pre><code>                                1  1  1  1  1  1
  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                                               |
/                     QNAME                     /
/                                               /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                     QTYPE                     |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                     QCLASS                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ ```
</code></pre>

<p>QNAME结构：<strong>域名字符串按照<code>.</code>分割，按照字符长度+字符依次排列，00结尾</strong>。</p>

<p>比如www.google.com.hk，在抓包里QNAME的视图如下：</p>

<p><strong>03</strong> 77 77 77 <strong>06</strong> 67 6f 6f 67 6c 65 <strong>03</strong> 63 6f 6d <strong>02</strong> 68 6b 00</p>

<p>解读：03个字符（www），06个字符（google），03个字符（com），02个字符（hk），结尾是00</p>

<p>QType：长度16位，表示查询类型<br />
QClass:长度为16位，表示分类</p>

<h2 id="dns-2">2.4  一个典型的DNS查询包</h2>

<p>下面是<code>wireshark</code>抓取的一个DNS查询包：</p>

<p><code>
(前面是以太网包头+IP包头+UDP包头)6d 54 01 00 00 01
00 00 00 00 00 00 03 77    77 77 06 67 6f 6f 67 6c 
65 03 63 6f 6d 02 68 6b    00 00 01 00 01
</code></p>

<p><code>6d 54</code>是标识，每次查询变化，DNS回应本次查询会用相同的标识<br />
<code>01 00</code>是标志，表示RD期望递归为1<br />
<code>00 01</code>是问题数，一个问题查询；其他三个查询记录数都是0<br />
接下来是QName，结构如上文说明<br />
倒数第二个<code>00 01</code>是QType，值是1<br />
最后一个<code>00 01</code>是QClass，值是是1  </p>

<p><code>
enum QueryType //查询的资源记录类型。 
{ 
A=0x01, //指定计算机 IP 地址。 
NS=0x02, //指定用于命名区域的 DNS 名称服务器。 
MD=0x03, //指定邮件接收站（此类型已经过时了，使用MX代替） 
MF=0x04, //指定邮件中转站（此类型已经过时了，使用MX代替） 
CNAME=0x05, //指定用于别名的规范名称。 
SOA=0x06, //指定用于 DNS 区域的“起始授权机构”。 
MB=0x07, //指定邮箱域名。 
MG=0x08, //指定邮件组成员。 
MR=0x09, //指定邮件重命名域名。 
NULL=0x0A, //指定空的资源记录 
WKS=0x0B, //描述已知服务。 
PTR=0x0C, //如果查询是 IP 地址，则指定计算机名；否则指定指向其它信息的指针。 
HINFO=0x0D, //指定计算机 CPU 以及操作系统类型。 
MINFO=0x0E, //指定邮箱或邮件列表信息。 
MX=0x0F, //指定邮件交换器。 
TXT=0x10, //指定文本信息。 
UINFO=0x64, //指定用户信息。 
UID=0x65, //指定用户标识符。 
GID=0x66, //指定组名的组标识符。 
ANY=0xFF //指定所有数据类型。 
};
</code></p>

<p><code>
enum QueryClass //指定信息的协议组。 
{ 
IN=0x01, //指定 Internet 类别。 
CSNET=0x02, //指定 CSNET 类别。（已过时） 
CHAOS=0x03, //指定 Chaos 类别。 
HESIOD=0x04,//指定 MIT Athena Hesiod 类别。 
ANY=0xFF //指定任何以前列出的通配符。 
};
</code></p>

<h3 id="section-2">学习资料</h3>

<ol>
  <li>
    <p><a href="https://www.ietf.org/rfc/rfc1035.txt">rfc1035</a></p>
  </li>
  <li>
    <p><a href="http://www.zytrax.com/books/dns/ch15/">Chapter 15 DNS Messages</a></p>
  </li>
  <li>
    <p><a href="http://www.iprotocolsec.com/2012/01/13/%E4%BD%BF%E7%94%A8wireshark%E5%AD%A6%E4%B9%A0dns%E5%8D%8F%E8%AE%AE%E5%8F%8Adns%E6%AC%BA%E9%AA%97%E5%8E%9F%E7%90%86/">使用Wireshark学习DNS协议及DNS欺骗原理</a></p>
  </li>
  <li>
    <p><a href="http://www.cnblogs.com/topdog/archive/2011/11/15/2250185.html">DIY一个DNS查询器：了解DNS协议</a></p>
  </li>
  <li>
    <p><a href="https://www.ezloo.com/2011/04/a_mx_cname_txt_aaaa_ns.html">常用域名记录解释：A记录、MX记录、CNAME记录、TXT记录、AAAA记录、NS记录</a></p>
  </li>
  <li>
    <p><a href="http://ju.outofmemory.cn/entry/187521">域名DNS解析相关概念 — A记录，MX记录，CNAME记录，url转发，ns记录</a></p>
  </li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TCP/IP之IP包头部]]></title>
    <link href="http://xixitalk.github.io/blog/2016/10/10/ipheader-of-tcpip/"/>
    <updated>2016-10-10T17:03:51+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/10/10/ipheader-of-tcpip</id>
    <content type="html"><![CDATA[<p>TCP/IP之IP包头部</p>

<!--more-->

<p><img src="http://www.informit.com/content/images/chap3_0672323516/elementLinks/03table02.gif" alt="iphead" /></p>

<h3 id="ip">IP包头</h3>

<table border="1">
  <tbody>
    <tr>
      <td>4位版本</td>
      <td>4位首部长度</td>
      <td>8位服务类型</td>
      <td>16位总长度</td>
    </tr>
    <tr>
      <td>16位标识</td>
      <td>3位标志</td>
      <td>13位片偏移</td>
      <td> </td>
    </tr>
    <tr>
      <td>8位生存时间（TTL）</td>
      <td>8位协议</td>
      <td>16位首部校验和</td>
      <td> </td>
    </tr>
    <tr>
      <td>32位源IP地址</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>32位目的IP地址</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>可选字段</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>不定长度数据</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>4位版本：4表示IPv4<br />
4位首部长度：一般是5，标识首部20bytes<br />
<strong>注释： <code>08 00 45 00</code>是典型的IP包特征</strong>,08 00是以太网帧头中IP包类型标识<br />
8位服务类型：<br />
16位总长度：整个IP包长度（如果数据是UDP包，包含了UDP包的长度）<br />
8位协议：<strong>0x11是UDP，0x06是TCP</strong><br />
8位TTL：0x80（128）</p>

<h3 id="udp">UDP包头</h3>

<table border="1">
  <tbody>
    <tr>
      <td>16位源端口</td>
      <td>16位目的端口</td>
    </tr>
    <tr>
      <td>16位长度</td>
      <td>16位校验和</td>
    </tr>
  </tbody>
</table>

<p>整个UDP包头8个字节。<br />
16位长度：包括UDP头和数据包（比如上层DNS协议）</p>

<p>READ MORE<br />
<a href="http://www.informit.com/articles/article.aspx?p=28782&amp;seqNum=3">http://www.informit.com/articles/article.aspx?p=28782&amp;seqNum=3</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TCP/IP之以太网帧]]></title>
    <link href="http://xixitalk.github.io/blog/2016/10/10/Ethernet-of-tcpip/"/>
    <updated>2016-10-10T10:15:46+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/10/10/Ethernet-of-tcpip</id>
    <content type="html"><![CDATA[<h3 id="ethernet-iiv2">Ethernet II(以太网V2帧)</h3>

<!--more-->

<table border="1">
  <thead>
    <tr>
      <th>6字节</th>
      <th>6字节</th>
      <th>2字节</th>
      <th>46-1500字节</th>
      <th>4字节</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>目标MAC地址</td>
      <td>源MAC地址</td>
      <td>类型</td>
      <td>数据</td>
      <td>FCS</td>
    </tr>
  </tbody>
</table>

<p><strong>类型</strong>：  08 00 是IP包，08 06 是ARP包<br />
<strong>数据</strong>：  最常见的是IP包<br />
<strong>FCS</strong>：   Frame check sequence帧校验序列  </p>

<p>更多常见类型：  </p>

<table border="1">
  <thead>
    <tr>
      <th>类型值</th>
      <th>解释</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x0800</td>
      <td>网际协议（IP）</td>
    </tr>
    <tr>
      <td>0x0806</td>
      <td>地址解析协议（ARP ： Address Resolution Protocol）</td>
    </tr>
    <tr>
      <td>0x0808</td>
      <td>帧中继 ARP （Frame Relay ARP） [RFC1701]</td>
    </tr>
    <tr>
      <td>0x814C</td>
      <td>简单网络管理协议（SNMP：Simple Network Management Protocol）</td>
    </tr>
    <tr>
      <td>0x86DD</td>
      <td>网际协议v6 （IPv6，Internet Protocol version 6）</td>
    </tr>
    <tr>
      <td>0x880B</td>
      <td>点对点协议（PPP：Point-to-Point Protocol）</td>
    </tr>
    <tr>
      <td>0x8847</td>
      <td>多协议标签交换（单播）（MPLS：Multi-Protocol Label Switching unicast）</td>
    </tr>
    <tr>
      <td>0x8848</td>
      <td>多协议标签交换（组播）（MPLS, Multi-Protocol Label Switching multicast）</td>
    </tr>
  </tbody>
</table>

<p>More Read  <a href="http://technow.blog.51cto.com/746816/320773">http://technow.blog.51cto.com/746816/320773</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DNS在HTTP网络交互流程中的位置]]></title>
    <link href="http://xixitalk.github.io/blog/2016/10/09/http-connection/"/>
    <updated>2016-10-09T08:55:37+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/10/09/http-connection</id>
    <content type="html"><![CDATA[<p>DNS在HTTP网络交互流程中的位置</p>

<!--more-->

<p>一个简单的HTTP请求流程（C语言版）</p>

<ol>
  <li>建立socket(socket())</li>
  <li>由域名查询到IP(getaddrinfo()或者gethostbyname())</li>
  <li>建立连接(connect())</li>
  <li>按照HTTP协议要求发送数据(send())</li>
  <li>监听socket等待接收数据(select())</li>
  <li>监听到数据后接收数据(recv())</li>
  <li>按照HTTP协议解析数据，再发送数据或者结束</li>
</ol>

]]></content>
  </entry>
  
</feed>
