<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tech | xixitalk's snippet]]></title>
  <link href="http://xixitalk.github.io/blog/categories/tech/atom.xml" rel="self"/>
  <link href="http://xixitalk.github.io/"/>
  <updated>2017-09-02T22:28:47+00:00</updated>
  <id>http://xixitalk.github.io/</id>
  <author>
    <name><![CDATA[xixitalk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[树莓派3上编译haproxy]]></title>
    <link href="http://xixitalk.github.io/blog/2017/09/03/compile-haproxy-on-raspberry3/"/>
    <updated>2017-09-03T06:01:08+00:00</updated>
    <id>http://xixitalk.github.io/blog/2017/09/03/compile-haproxy-on-raspberry3</id>
    <content type="html"><![CDATA[<p>最近发现树莓派上haproxy有点问题，Google Play下载有些不正常。所以想更新编译haproxy。raspbian软件仓库的haproxy的版本比较低，所以直接下载haproxy源代码编译。更新过程记录下来。</p>

<!--more-->

<p>为了配置省事，建议先安装raspbian软件仓库里的haproxy，然后编译好的haproxy的直接覆盖，这样启动配置不用费心配置。</p>

<p>1、下载源代码并解压</p>

<p><code>
wget http://www.haproxy.org/download/1.7/src/haproxy-1.7.9.tar.gz
tar xzvf haproxy-1.7.9.tar.gz
cd haproxy-1.7.9/
</code></p>

<p>2、编译</p>

<p>haproxy不能直接make，需要带配置参数。先查看已经安装的haproxy的编译参数。</p>

<p><code>
haproxy -vv OPTIONS = USE_GETADDRINFO=1
</code></p>

<p>执行上面的命令会得到类似以下信息。</p>

<p><code>
Build options :
  TARGET  = linux2628
  CPU     = generic
  CC      = gcc
  CFLAGS  = -O2 -g -fno-strict-aliasing -Wdeclaration-after-statement
  OPTIONS =
</code></p>

<p>make编译</p>

<p><code>
make  TARGET=linux2628   CPU=generic  CFLAGS="-O2 -g -fno-strict-aliasing -Wdeclaration-after-statement"
</code></p>

<p>正常编译完，在haproxy-1.7.9目录下就会生成haproxy可执行文件。用<code>./haproxy -vv</code>查看编译好的haproxy版本号。</p>

<p>3、替换系统里的haproxy</p>

<p><code>
$which haproxy
/usr/sbin/haproxy
$sudo service haproxy stop
$sudo cp ./haproxy /usr/sbin/haproxy
$sudo service haproxy start
</code></p>

<p>4、haproxy负载平衡shadowsocks配置参考</p>

<p><code>14826</code>是haproxy提供的端口，<code>12222</code>是haproxy的状态web端口，可以用浏览器访问http://IP:12222查看haproxy状态。<code>j1.vps.com</code>等是多个SS server端。SS local访问haproxy的<code>14826</code>端口，IP为haproxy的侦听IP，SS local其他配置和直接访问SS server是一样的。</p>

<p>```
global
ulimit-n 51200
defaults
log global
mode tcp
option dontlognull
balance roundrobin
option persist
timeout connect 10000
timeout client 150000
timeout server 150000</p>

<p>listen stats
bind *:12222
mode http
stats enable
stats uri /
stats refresh 10s</p>

<p>retries 1
option redispatch
frontend ss-in
bind *:14826
default_backend ss-out
backend ss-out
server j1 j1.vps.com:29777 maxconn 20480 weight 1
server j2 j2.vps.com:29777 maxconn 20480 weight 100
server us0 us0.vps.com:29777 maxconn 20480 weight 1 backup
server us1 us1.vps.com:29777 maxconn 20480 weight 1 backup
server us2 us2.vps.com:29777 maxconn 20480 weight 1 backup
server us3 us3.vps.com:29777 maxconn 20480 weight 1 backup
```</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[华硕路由器外接硬盘格式化成什么文件系统最好]]></title>
    <link href="http://xixitalk.github.io/blog/2016/11/12/How-to-Format-Usb-Drive-for-asus-router/"/>
    <updated>2016-11-12T15:33:41+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/11/12/How-to-Format-Usb-Drive-for-asus-router</id>
    <content type="html"><![CDATA[<p>关键词：华硕 AC66U AC68U 外接硬盘 文件系统 EXT4 EXT3 NTFS FAT32</p>

<p>我有一台华硕AC66U，外接了一块2.5吋移动硬盘。不知道格式化成什么格式最好？硬盘本来是EXT4格式的，插上发现没有自动挂载，搜索发现，AC66U建议用<strong>EXT3</strong>格式，而AC68U建议用<strong>EXT4</strong>格式。果然格式成EXT3后，插上AC66U后<strong>自动挂载</strong>了。其他华硕机器未验证。</p>

<!--more-->

<blockquote>
  <p>For usb hdd Mipsel devices is EXT3 (RT-N16, RT-N66U, RT-AC66U and all other versions: /R /W)</p>
</blockquote>

<p>RT-N16, RT-N66U, RT-AC66U是<a href="https://en.wikipedia.org/wiki/MIPS_instruction_set">MIPS</a>架构的CPU，建议最好格式化成EXT3.</p>

<blockquote>
  <p>For usb hdd ARM devices is EXT4 (RT-AC56U, RT-AC68U, RT-AC87U, RT-AC88U, RT-AC3200, RT-AC5300 and all other versions: /P /R /W)</p>
</blockquote>

<p>RT-AC56U, RT-AC68U, RT-AC87U, RT-AC88U, RT-AC3200, RT-AC5300是<a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a>架构的CPU，建议最好格式化成EXT4.</p>

<p>华硕路由器系统是Linux，对windows的NTFS和FAT32支持并不好，所以建议外接硬盘使用EXT4或者EXT3，如果都不支持也许应该升级路由器了。</p>

<h2 id="section">参考文章</h2>

<p><a href="https://www.hqt.ro/how-to-format-usb-drive/">How to Format Usb Drive</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pkcs11-helper编译]]></title>
    <link href="http://xixitalk.github.io/blog/2016/11/01/pkcs11-helper-build/"/>
    <updated>2016-11-01T18:37:08+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/11/01/pkcs11-helper-build</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/OpenSC/pkcs11-helper/releases">pkcs11-helper</a>也真是的，软件包里<code>INSTALL</code>里说用<code>./configure</code>生成<code>Makefile</code>，但是软件包还没有<code>configure</code>文件，需要<code>autoreconf</code>生成<code>configure</code>文件。妈蛋，<code>INSTALL</code>多写一句<code>autoreconf -ivf</code>会死吗？</p>

<!--more-->

<h1 id="section">准备</h1>

<p>确保系统安装了<code>autoconf</code> <code>automake</code> <code>libtool</code></p>

<h1 id="section-1">下载源代码解压</h1>

<p><code>
$wget https://github.com/OpenSC/pkcs11-helper/archive/pkcs11-helper-1.10.tar.gz
$tar -zxvf pkcs11-helper-1.10.tar.gz
$cd pkcs11-helper-pkcs11-helper-1.10
</code></p>

<h1 id="makefile">生成Makefile</h1>

<p><code>
$autoreconf -ivf
$./configure
</code></p>

<h1 id="section-2">编译安装</h1>

<p><code>
$make
$make install
</code></p>

<h1 id="section-3">参考</h1>

<p><a href="https://github.com/OpenSC/pkcs11-helper/issues/2">https://github.com/OpenSC/pkcs11-helper/issues/2</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[stunnel verify选项配置]]></title>
    <link href="http://xixitalk.github.io/blog/2016/10/18/stunnel-verify-config/"/>
    <updated>2016-10-18T09:12:59+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/10/18/stunnel-verify-config</id>
    <content type="html"><![CDATA[<p>verify配置认证方式，取值0 1 2 3 4。</p>

<p>0 - request and ignore peer cert<br />
1 - only validate peer cert if present<br />
2 - always require a valid peer cert<br />
3 - verify peer with locally installed cert<br />
4 - ignore CA chain and only verify peer cert  </p>

<!--more-->

<h2 id="stunnel5-verify">stunnel5 verify配置</h2>

<p>代码版本<code>stunnel 5.36</code>  文件<code>option.c</code>  函数<code>parse_service_option()</code></p>

<p><code>
    case CMD_EXEC:
        if(strcasecmp(opt, "verify"))
            break;
        {
            char *tmp_str;
            int tmp_int=(int)strtol(arg, &amp;tmp_str, 10);
            if(tmp_str==arg || *tmp_str || tmp_int&lt;0 || tmp_int&gt;4)
                return "Bad verify level";
            section-&gt;option.request_cert=1;
            section-&gt;option.require_cert=(tmp_int&gt;=2);
            section-&gt;option.verify_chain=(tmp_int&gt;=1 &amp;&amp; tmp_int&lt;=3);
            section-&gt;option.verify_peer=(tmp_int&gt;=3);
        }
        return NULL; /* OK */
</code></p>

<p><code>verify</code>选项合法值为：0  1 2 3 4</p>

<table>
  <thead>
    <tr>
      <th>取值</th>
      <th>request_cert</th>
      <th>require_cert</th>
      <th>verify_chain</th>
      <th>verify_peer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>√</td>
      <td>×</td>
      <td>×</td>
      <td>×</td>
    </tr>
    <tr>
      <td>1</td>
      <td>√</td>
      <td>×</td>
      <td>√</td>
      <td>×</td>
    </tr>
    <tr>
      <td>2</td>
      <td>√</td>
      <td>√</td>
      <td>√</td>
      <td>×</td>
    </tr>
    <tr>
      <td>3</td>
      <td>√</td>
      <td>√</td>
      <td>√</td>
      <td>√</td>
    </tr>
    <tr>
      <td>4</td>
      <td>√</td>
      <td>√</td>
      <td>×</td>
      <td>√</td>
    </tr>
  </tbody>
</table>

<p>conf配置文件里，<code>requireCert</code>可以修改require_cert，<code>verifyChain</code>可以修改<code>verify_chain</code>，<code>verifyPeer</code>可以修改<code>verify_peer</code>。</p>

<p>根据上表可得出，stunnel5里<code>verify = 3</code>最全面。</p>

<p>我自己服务器端是<code>verify = 3</code>，客户端用的是<code>verify = 4</code>。</p>

<p><code>
verify = 4
verifyChain = no
verifyPeer = yes
</code></p>

<p>如果是stunnel4，配置<code>verify = 3</code>即可，点对点连接推荐3。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[stunnel双向证书认证]]></title>
    <link href="http://xixitalk.github.io/blog/2016/10/13/Stunnel-With-Bilateral-Authentication/"/>
    <updated>2016-10-13T20:09:49+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/10/13/Stunnel-With-Bilateral-Authentication</id>
    <content type="html"><![CDATA[<p>stunnel 双向证书认证：<strong>防止没授权的客户端连接stunnel服务器，防止客户端连接假的服务器</strong>。</p>

<p>stunnel官方的<a href="https://www.stunnel.org/auth.html">说明</a>是：（客户端）检查服务器端证书是为了防止<strong>中间人攻击</strong>；（服务器端）检查客户端证书是为了严格控制客户端的访问。</p>

<ol>
  <li>Server authentication prevents <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">Man-In-The-Middle</a> (MITM) attacks on the encryption protocol.</li>
  <li>Client authentication allows for restricting access for individual clients (access control).</li>
</ol>

<!--more-->

<h2 id="stunnel">stunnel安全说明</h2>

<p>stunnel有四种证书检查配置，用<code>verify</code>选项控制。</p>

<ol>
  <li><strong>Do not Verify Certificates</strong>  不检查证书，<strong>默认值</strong><br />
If no verify argument is given, then stunnel will ignore any certificates offered and will allow all connections.</li>
  <li><strong>verify = 1</strong>  如果证书存在则检查证书<br />
Verify the certificate, if present.  </li>
  <li><strong>verify = 2</strong>  每个SSL连接要求检查证书<br />
Require and verify certificates<br />
Stunnel will require and verify certificates for every SSL connection. If no certificate or an invalid certificate is presented, then it will drop the connection.</li>
  <li><strong>verify = 3</strong>  依据本地安装的证书检查证书<br />
Require and verify certificates against locally installed certificates.</li>
  <li><strong>verify = 4</strong>  忽略CA chain，只验证peer certificate<br />
ignore CA chain and only verify peer certificate</li>
</ol>

<p>当<code>verify</code>配置2 3 4的时候，都会开启双向证书认证，自行选择。这里选择<code>verify = 3</code>。</p>

<p>stunnel服务端的<strong>防盗</strong>连安全机制是：在服务器<code>CAfile</code>里配置客户端的证书，并设置<code>verify = 3</code>，服务器端检查客户端证书，证书不在<code>CAfile</code>列表的客户端则会被断开连接。</p>

<p>同样，为了避免客户端连接到<strong>假的服务端</strong>，则需要配置<code>verify = 3</code>，并把服务端的<strong>公钥证书</strong>放在客户端侧的<code>CAfile</code>里。</p>

<h2 id="section">第一步 生成证书</h2>

<p>生成两个证书，一个服务端的<code>stunnel_s.pem</code>，一个客户端的<code>stunnel_c.pem</code>，有效期设置长一点，10000天，时间可以自行调整。</p>

<p><code>
$openssl req -new -x509 -days 10000 -nodes -out stunnel_c.pem -keyout stunnel_c.pem
$openssl req -new -x509 -days 10000 -nodes -out stunnel_s.pem -keyout stunnel_s.pem
</code></p>

<h2 id="stunnelconf">第二步 服务器端stunnel.conf</h2>

<p>将证书拷贝到/etc/stunnel目录，设置权限400（文件拥有者只读，其他人不可查看）.</p>

<p><code>
$sudo cp stunnel_s.pem /etc/stunnel/
$sudo cp stunnel_c.pem /etc/stunnel/
$sudo chmod 400 /etc/stunnel/*.pem
</code></p>

<p>创建<code>stunnel.conf</code>文件，内容如下，拷贝到<code>/etc/stunnel/</code>目录。对外端口是8445，加密的是<a href="https://github.com/cyfdecyf/cow">cow HTTP proxy</a>的7777端口连接,根据情况自行修改。如果要调试打开<code>output</code>选项。cow是个HTTP代理，智能分流值得推荐。</p>

<p>```
;fips=no
client = no
sslVersion=all</p>

<p>chroot = /var/lib/stunnel4/
setuid = root
setgid = root</p>

<p>pid = /stunnel4.open.pid
;output = /stunnel.open.log
cert = /etc/stunnel/stunnel_s.pem
key = /etc/stunnel/stunnel_s.pem</p>

<p>[open]
accept = 8445
connect = 7777</p>

<p>verify = 3
CAfile = /etc/stunnel/stunnel_c.pem
```</p>

<p>重启stunnel服务器</p>

<p><code>
$sudo service  stunnel4  restart
</code></p>

<h2 id="stunnelconf-1">第三步 客户端stunnel.conf</h2>

<p>我的客户端运行在windows系统，所以下面的配置是windows上stunnel验证的。其他系统配置类似，自行配置验证。</p>

<p>将<code>stunnel_c.pem</code>和<code>stunnel_s.pem</code>（存放在客户端的stunnel_s.pem最好删除证书里BEGIN PRIVATE KEY私钥部分，只保留BEGIN CERTIFICATE公钥部分）拷贝到<code>stunnel</code>安装目录，修改<code>stunnel.conf</code>文件，配置如下。<code>stunnel_ip</code>是服务器端stunnel的IP，端口是8084，浏览器配置127.0.0.1:8084 HTTP代理。如果要换其他端口自行修改。</p>

<p>```
fips=no
client = yes
sslVersion = all
socket = l:TCP_NODELAY=1
socket = r:TCP_NODELAY=1
socket = l:SO_LINGER=1:1
socket = r:SO_LINGER=1:1</p>

<p>[fastssl]
accept = 127.0.0.1:8084
connect = stunnel_ip:8445</p>

<p>verify = 3
CAfile = stunnel_s.pem</p>

<p>cert = stunnel_c.pem
key = stunnel_c.pem
```</p>

<p>如果客户端连接<code>stunnel</code>服务器端需要HTTP代理（公司网络），<code>fastssl</code>部分这样配置</p>

<p><code>
[fastssl]
accept = 127.0.0.1:8084
connect = proxy.company.com:80
protocol = connect
protocolHost = stunnel_ip:8445
</code></p>

<h2 id="pem">pem证书安全存放说明</h2>

<p>pem证书是文本文件，里面<code>BEGIN PRIVATE KEY</code>和<code>END PRIVATE KEY</code>是私钥部分，<code>BEGIN CERTIFICATE</code>和<code>END CERTIFICATE</code>是公钥部分。<code>cert</code>和<code>key</code>配置完整的pem，而<code>CAfile</code>里只包含对方的公钥部分即可，即服务端<code>CAfile</code>是客户端的公钥，客户端<code>CAfile</code>是服务端的公钥。遵循这样原则，客户端的私钥只放客户端，服务端的私钥只放服务端，而公钥是可以多处存放的。</p>

<p><code>
-----BEGIN PRIVATE KEY-----
MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQCo9WC13gg9WCRX
...
kPpWg2PAANRi5Bmr9ScvBISSYQ==
-----END PRIVATE KEY-----
-----BEGIN CERTIFICATE-----
MIID6TCCAtGgAwIBAgIJANBMqvP0YuV4MA0GCSqGSIb3DQEBBQUAMIGKMQswCQYD
...
o5tKoL9GcMhyjDoD9GCMfP6fY5DwPqhhqFTsPd47DzEdQ8amxPMn5kR/w/xk
-----END CERTIFICATE-----
</code></p>

<p>多个公钥证书保存在一个<code>CAfile</code>里，这样排列存放。<a href="https://www.stunnel.org/howto.html">官方说明Where do I put all these certificates?</a>。</p>

<p><code>
-----BEGIN CERTIFICATE-----
certificate #1 data here
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
certificate #2 data here
-----END CERTIFICATE-----
</code></p>

<h2 id="section-1">参考博客</h2>

<ol>
  <li><a href="http://www.hawu.me/operation/886">squid + stunnel » 跨越长城，科学上网！</a></li>
  <li><a href="http://briteming.blogspot.com/2013/03/stunnel.html">Using stunnel With Bilateral Authentication</a></li>
  <li><a href="https://sunmaiblog.wordpress.com/2010/09/21/stunnel%E7%9A%84%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/">Stunnel的设置和使用</a></li>
</ol>

]]></content>
  </entry>
  
</feed>
